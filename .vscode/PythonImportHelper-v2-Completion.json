[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "tensorflow.keras",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "tensorflow.compat.v1",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow.compat.v1",
        "description": "tensorflow.compat.v1",
        "detail": "tensorflow.compat.v1",
        "documentation": {}
    },
    {
        "label": "sklearn.cluster",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "sklearn.mixture",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sklearn.mixture",
        "description": "sklearn.mixture",
        "detail": "sklearn.mixture",
        "documentation": {}
    },
    {
        "label": "scipy.cluster.hierarchy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.cluster.hierarchy",
        "description": "scipy.cluster.hierarchy",
        "detail": "scipy.cluster.hierarchy",
        "documentation": {}
    },
    {
        "label": "poly_derivative",
        "kind": 5,
        "importPath": "math.calculus.10-main",
        "description": "math.calculus.10-main",
        "peekOfCode": "poly_derivative = __import__('10-matisse').poly_derivative\npoly = [5, 3, 0, 1]\nprint(poly_derivative(poly))",
        "detail": "math.calculus.10-main",
        "documentation": {}
    },
    {
        "label": "poly",
        "kind": 5,
        "importPath": "math.calculus.10-main",
        "description": "math.calculus.10-main",
        "peekOfCode": "poly = [5, 3, 0, 1]\nprint(poly_derivative(poly))",
        "detail": "math.calculus.10-main",
        "documentation": {}
    },
    {
        "label": "poly_derivative",
        "kind": 2,
        "importPath": "math.calculus.10-matisse",
        "description": "math.calculus.10-matisse",
        "peekOfCode": "def poly_derivative(poly):\n    \"\"\"A function that calculates the derivative of a polynomial\"\"\"\n    if type(poly) is not list or len(poly) == 0:\n        return None\n    for coeff in poly:\n        if type(coeff) not in (int, float):\n            return None\n    if len(poly) == 1:\n        return [0]\n    derivative = []",
        "detail": "math.calculus.10-matisse",
        "documentation": {}
    },
    {
        "label": "poly_integral",
        "kind": 2,
        "importPath": "math.calculus.17-integrate",
        "description": "math.calculus.17-integrate",
        "peekOfCode": "def poly_integral(poly, C=0):\n    \"\"\"A function that calculates the integral of a polynomial\"\"\"\n    if type(poly) is not list or len(poly) == 0:\n        return None\n    if type(C) not in (int, float):\n        return None\n    for coeff in poly:\n        if type(coeff) not in (int, float):\n            return None\n    result = [C]",
        "detail": "math.calculus.17-integrate",
        "documentation": {}
    },
    {
        "label": "poly_integral",
        "kind": 5,
        "importPath": "math.calculus.17-main",
        "description": "math.calculus.17-main",
        "peekOfCode": "poly_integral = __import__('17-integrate').poly_integral\npoly = [5, 3, 0, 1]\nprint(poly_integral(poly))",
        "detail": "math.calculus.17-main",
        "documentation": {}
    },
    {
        "label": "poly",
        "kind": 5,
        "importPath": "math.calculus.17-main",
        "description": "math.calculus.17-main",
        "peekOfCode": "poly = [5, 3, 0, 1]\nprint(poly_integral(poly))",
        "detail": "math.calculus.17-main",
        "documentation": {}
    },
    {
        "label": "summation_i_squared",
        "kind": 5,
        "importPath": "math.calculus.9-main",
        "description": "math.calculus.9-main",
        "peekOfCode": "summation_i_squared = __import__('9-sum_total').summation_i_squared\nn = 5\nprint(summation_i_squared(n))",
        "detail": "math.calculus.9-main",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "math.calculus.9-main",
        "description": "math.calculus.9-main",
        "peekOfCode": "n = 5\nprint(summation_i_squared(n))",
        "detail": "math.calculus.9-main",
        "documentation": {}
    },
    {
        "label": "summation_i_squared",
        "kind": 2,
        "importPath": "math.calculus.9-sum_total",
        "description": "math.calculus.9-sum_total",
        "peekOfCode": "def summation_i_squared(n):\n    \"\"\" A function that calculates the sum of squares\"\"\"\n    if type(n) is not int or n < 1:\n        return None\n    result = (n * (n + 1) * (2 * n + 1)) / 6\n    return int(result)",
        "detail": "math.calculus.9-sum_total",
        "documentation": {}
    },
    {
        "label": "convolve_grayscale_valid",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.0-convolve_grayscale_valid",
        "description": "math.convolutions_and_pooling.0-convolve_grayscale_valid",
        "peekOfCode": "def convolve_grayscale_valid(images, kernel):\n    \"\"\"\n        A function that performs a valid convolution on grayscale images\n        :param images: ndarray, shape(m, h, w), multiple grayscale images\n        :param kernel: ndarray, shape(kh,kw), kernel for convolution\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images and kernel\n    m, h, w = images.shape\n    kh, kw = kernel.shape",
        "detail": "math.convolutions_and_pooling.0-convolve_grayscale_valid",
        "documentation": {}
    },
    {
        "label": "convolve_grayscale_same",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.1-convolve_grayscale_same",
        "description": "math.convolutions_and_pooling.1-convolve_grayscale_same",
        "peekOfCode": "def convolve_grayscale_same(images, kernel):\n    \"\"\"\n        A function that performs a same convolution on grayscale images\n        :param images: ndarray, shape(m, h, w), multiple grayscale images\n        :param kernel: ndarray, shape(kh,kw), kernel for convolution\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images and kernel\n    m, h, w = images.shape\n    kh, kw = kernel.shape",
        "detail": "math.convolutions_and_pooling.1-convolve_grayscale_same",
        "documentation": {}
    },
    {
        "label": "convolve_grayscale_padding",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.2-convolve_grayscale_padding",
        "description": "math.convolutions_and_pooling.2-convolve_grayscale_padding",
        "peekOfCode": "def convolve_grayscale_padding(images, kernel, padding):\n    \"\"\"\n        A function that performs a convolution on grayscale images\n        with custom padding\n        :param images: ndarray, shape(m, h, w), multiple grayscale images\n        :param kernel: ndarray, shape(kh,kw), kernel for convolution\n        :param padding: tupple (ph,pw)\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images and kernel",
        "detail": "math.convolutions_and_pooling.2-convolve_grayscale_padding",
        "documentation": {}
    },
    {
        "label": "convolve_grayscale",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.3-convolve_grayscale",
        "description": "math.convolutions_and_pooling.3-convolve_grayscale",
        "peekOfCode": "def convolve_grayscale(images, kernel, padding='same', stride=(1, 1)):\n    \"\"\"\n        A function that performs a convolution on grayscale images\n        :param images: ndarray, shape(m, h, w), multiple grayscale images\n        :param kernel: ndarray, shape(kh,kw), kernel for convolution\n        :param padding: tuple (ph,pw) and 'same\" or \"valid'\n        :param stride: tuple (sh, sw)\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images, kernel, padding, stride",
        "detail": "math.convolutions_and_pooling.3-convolve_grayscale",
        "documentation": {}
    },
    {
        "label": "convolve_channels",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.4-convolve_channels",
        "description": "math.convolutions_and_pooling.4-convolve_channels",
        "peekOfCode": "def convolve_channels(images, kernel, padding='same', stride=(1, 1)):\n    \"\"\"\n        A function that performs a convolution on images with channels\n        :param images: ndarray, shape(m, h, w, c), multiple images\n        :param kernel: ndarray, shape(kh,kw, c), kernel for convolution\n        :param padding: tuple (ph,pw) or 'same\" or \"valid'\n        :param stride: tuple (sh, sw)\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images, kernel, padding, stride",
        "detail": "math.convolutions_and_pooling.4-convolve_channels",
        "documentation": {}
    },
    {
        "label": "convolve",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.5-convolve",
        "description": "math.convolutions_and_pooling.5-convolve",
        "peekOfCode": "def convolve(images, kernel, padding='same', stride=(1, 1)):\n    \"\"\"\n        A function that performs a convolution on images using multiple kernel\n        :param images: ndarray, shape(m, h, w, c), multiple images\n        :param kernel: ndarray, shape(kh,kw,c,nc), kernel for convolution\n        :param padding: tuple (ph,pw) or 'same\" or \"valid'\n        :param stride: tuple (sh, sw)\n        :return: ndarray containing convolved images\n    \"\"\"\n    # size images, kernel, padding, stride",
        "detail": "math.convolutions_and_pooling.5-convolve",
        "documentation": {}
    },
    {
        "label": "pool",
        "kind": 2,
        "importPath": "math.convolutions_and_pooling.6-pool",
        "description": "math.convolutions_and_pooling.6-pool",
        "peekOfCode": "def pool(images, kernel_shape, stride, mode='max'):\n    \"\"\"\n        A function that performs pooling on images\n        :param images: ndarray, shape(m, h, w, c), multiple images\n        :param kernel_shape: ndarray, shape(kh,kw), kernel shape for pooling\n        :param stride: tuple (sh, sw)\n        :param mode: type of pooling 'max' or 'avg'\n        :return: ndarray containing pooled images\n    \"\"\"\n    # size images, kernel, padding, stride",
        "detail": "math.convolutions_and_pooling.6-pool",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "math.linear_algebra.0-slice_me_up",
        "description": "math.linear_algebra.0-slice_me_up",
        "peekOfCode": "arr = [9, 8, 2, 3, 9, 4, 1, 0, 3]\narr1 = arr[:2]\narr2 = arr[-5:]\narr3 = arr[1:6]\nprint(\"The first two numbers of the array are: {}\".format(arr1))\nprint(\"The last five numbers of the array are: {}\".format(arr2))\nprint(\"The 2nd through 6th numbers of the array are: {}\".format(arr3))",
        "detail": "math.linear_algebra.0-slice_me_up",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "math.linear_algebra.0-slice_me_up",
        "description": "math.linear_algebra.0-slice_me_up",
        "peekOfCode": "arr1 = arr[:2]\narr2 = arr[-5:]\narr3 = arr[1:6]\nprint(\"The first two numbers of the array are: {}\".format(arr1))\nprint(\"The last five numbers of the array are: {}\".format(arr2))\nprint(\"The 2nd through 6th numbers of the array are: {}\".format(arr3))",
        "detail": "math.linear_algebra.0-slice_me_up",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "math.linear_algebra.0-slice_me_up",
        "description": "math.linear_algebra.0-slice_me_up",
        "peekOfCode": "arr2 = arr[-5:]\narr3 = arr[1:6]\nprint(\"The first two numbers of the array are: {}\".format(arr1))\nprint(\"The last five numbers of the array are: {}\".format(arr2))\nprint(\"The 2nd through 6th numbers of the array are: {}\".format(arr3))",
        "detail": "math.linear_algebra.0-slice_me_up",
        "documentation": {}
    },
    {
        "label": "arr3",
        "kind": 5,
        "importPath": "math.linear_algebra.0-slice_me_up",
        "description": "math.linear_algebra.0-slice_me_up",
        "peekOfCode": "arr3 = arr[1:6]\nprint(\"The first two numbers of the array are: {}\".format(arr1))\nprint(\"The last five numbers of the array are: {}\".format(arr2))\nprint(\"The 2nd through 6th numbers of the array are: {}\".format(arr3))",
        "detail": "math.linear_algebra.0-slice_me_up",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "math.linear_algebra.1-trim_me_down",
        "description": "math.linear_algebra.1-trim_me_down",
        "peekOfCode": "matrix = [[1, 3, 9, 4, 5, 8], [2, 4, 7, 3, 4, 0], [0, 3, 4, 6, 1, 5]]\nthe_middle = []\nfor row in matrix:\n    the_middle.append(row[2:4])\nprint(\"The middle columns of the matrix are: {}\".format(the_middle))",
        "detail": "math.linear_algebra.1-trim_me_down",
        "documentation": {}
    },
    {
        "label": "the_middle",
        "kind": 5,
        "importPath": "math.linear_algebra.1-trim_me_down",
        "description": "math.linear_algebra.1-trim_me_down",
        "peekOfCode": "the_middle = []\nfor row in matrix:\n    the_middle.append(row[2:4])\nprint(\"The middle columns of the matrix are: {}\".format(the_middle))",
        "detail": "math.linear_algebra.1-trim_me_down",
        "documentation": {}
    },
    {
        "label": "np_shape",
        "kind": 2,
        "importPath": "math.linear_algebra.10-ill_use_my_scale",
        "description": "math.linear_algebra.10-ill_use_my_scale",
        "peekOfCode": "def np_shape(matrix):\n    \"\"\"A function that calculates the shape of a numpy.ndarray\"\"\"\n    return matrix.shape",
        "detail": "math.linear_algebra.10-ill_use_my_scale",
        "documentation": {}
    },
    {
        "label": "np_shape",
        "kind": 5,
        "importPath": "math.linear_algebra.10-main",
        "description": "math.linear_algebra.10-main",
        "peekOfCode": "np_shape = __import__('10-ill_use_my_scale').np_shape\nmat1 = np.array([1, 2, 3, 4, 5, 6])\nmat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_shape(mat1))\nprint(np_shape(mat2))\nprint(np_shape(mat3))",
        "detail": "math.linear_algebra.10-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.10-main",
        "description": "math.linear_algebra.10-main",
        "peekOfCode": "mat1 = np.array([1, 2, 3, 4, 5, 6])\nmat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_shape(mat1))\nprint(np_shape(mat2))\nprint(np_shape(mat3))",
        "detail": "math.linear_algebra.10-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.10-main",
        "description": "math.linear_algebra.10-main",
        "peekOfCode": "mat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_shape(mat1))\nprint(np_shape(mat2))\nprint(np_shape(mat3))",
        "detail": "math.linear_algebra.10-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.10-main",
        "description": "math.linear_algebra.10-main",
        "peekOfCode": "mat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_shape(mat1))\nprint(np_shape(mat2))\nprint(np_shape(mat3))",
        "detail": "math.linear_algebra.10-main",
        "documentation": {}
    },
    {
        "label": "np_slice",
        "kind": 5,
        "importPath": "math.linear_algebra.100-main",
        "description": "math.linear_algebra.100-main",
        "peekOfCode": "np_slice = __import__('100-slice_like_a_ninja').np_slice\nmat1 = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\nprint(np_slice(mat1, axes={1: (1, 3)}))\nprint(mat1)\nmat2 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]],\n                 [[21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]])\nprint(np_slice(mat2, axes={0: (2,), 2: (None, None, -2)}))\nprint(mat2)",
        "detail": "math.linear_algebra.100-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.100-main",
        "description": "math.linear_algebra.100-main",
        "peekOfCode": "mat1 = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\nprint(np_slice(mat1, axes={1: (1, 3)}))\nprint(mat1)\nmat2 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]],\n                 [[21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]])\nprint(np_slice(mat2, axes={0: (2,), 2: (None, None, -2)}))\nprint(mat2)",
        "detail": "math.linear_algebra.100-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.100-main",
        "description": "math.linear_algebra.100-main",
        "peekOfCode": "mat2 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]],\n                 [[21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]])\nprint(np_slice(mat2, axes={0: (2,), 2: (None, None, -2)}))\nprint(mat2)",
        "detail": "math.linear_algebra.100-main",
        "documentation": {}
    },
    {
        "label": "np_slice",
        "kind": 2,
        "importPath": "math.linear_algebra.100-slice_like_a_ninja",
        "description": "math.linear_algebra.100-slice_like_a_ninja",
        "peekOfCode": "def np_slice(matrix, axes={}):\n    \"\"\"A function that slices a matrix along specific axes\"\"\"\n    slices = [slice(None)] * matrix.ndim\n    for axis in axes:\n        slices[axis] = slice(*axes[axis])\n    return matrix[tuple(slices)]",
        "detail": "math.linear_algebra.100-slice_like_a_ninja",
        "documentation": {}
    },
    {
        "label": "add_matrices",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "add_matrices = __import__('101-the_whole_barn').add_matrices\nmat1 = [1, 2, 3]\nmat2 = [4, 5, 6]\nprint(add_matrices(mat1, mat2))\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices(mat1, mat2))\nmat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat1 = [1, 2, 3]\nmat2 = [4, 5, 6]\nprint(add_matrices(mat1, mat2))\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices(mat1, mat2))\nmat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat2 = [4, 5, 6]\nprint(add_matrices(mat1, mat2))\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices(mat1, mat2))\nmat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices(mat1, mat2))\nmat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]\nmat2 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat2 = [[5, 6], [7, 8]]\nprint(add_matrices(mat1, mat2))\nmat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]\nmat2 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat1 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]\nmat2 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat2 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[133, 134, 135, 136], [137, 138, 139, 140]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]\nmat3 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.101-main",
        "description": "math.linear_algebra.101-main",
        "peekOfCode": "mat3 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]\nprint(add_matrices(mat1, mat2))\nprint(add_matrices(mat1, mat3))",
        "detail": "math.linear_algebra.101-main",
        "documentation": {}
    },
    {
        "label": "add_matrices",
        "kind": 2,
        "importPath": "math.linear_algebra.101-the_whole_barn",
        "description": "math.linear_algebra.101-the_whole_barn",
        "peekOfCode": "def add_matrices(mat1, mat2):\n    \"\"\"A function that adds two matrices\"\"\"\n    if type(mat1) is list and type(mat2) is list:\n        if len(mat1) != len(mat2):\n            return None\n        result = []\n        for i in range(len(mat1)):\n            temp = add_matrices(mat1[i], mat2[i])\n            if temp is None:\n                return None",
        "detail": "math.linear_algebra.101-the_whole_barn",
        "documentation": {}
    },
    {
        "label": "cat_matrices",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "cat_matrices = __import__('102-squashed_like_sardines').cat_matrices\nmat1 = [1, 2, 3]\nmat2 = [4, 5, 6]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat1 = [1, 2, 3]\nmat2 = [4, 5, 6]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat2 = [4, 5, 6]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat1 = [[1, 2], [3, 4]]",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nnp_mat1 = np.array(mat1)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat2 = [[5, 6], [7, 8]]\nnp_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat1 = np.array(mat1)\nnp_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat2 = np.array(mat2)\nt0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nm = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat1, mat2)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat1, mat2, axis=1)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat1, mat2, axis=1)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nnp.concatenate((np_mat1, np_mat2))\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat1, mat2, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat1, mat2, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((mat1, mat2), axis=1)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nm = cat_matrices(mat1, mat2, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((mat1, mat2), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat1, mat2, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((mat1, mat2), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((mat1, mat2), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nnp.concatenate((mat1, mat2), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0, \"\\n\")\nmat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]\nmat4 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat3 = [[[[1, 2, 3, 4], [5, 6, 7, 8]],\n         [[9, 10, 11, 12], [13, 14 ,15, 16]],\n         [[17, 18, 19, 20], [21, 22, 23, 24]]],\n        [[[25, 26, 27, 28], [29, 30, 31, 32]],\n         [[33, 34, 35, 36], [37, 38, 39, 40]],\n         [[41, 42, 43, 44], [45, 46, 47, 48]]]]\nmat4 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat4",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat4 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[19, 110, 111, 112], [113, 114 ,115, 116]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[133, 134, 135, 136], [137, 138, 139, 140]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]\nmat5 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "mat5",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "mat5 = [[[[11, 12, 13, 14], [15, 16, 17, 18]],\n         [[117, 118, 119, 120], [121, 122, 123, 124]]],\n        [[[125, 126, 127, 128], [129, 130, 131, 132]],\n         [[141, 142, 143, 144], [145, 146, 147, 148]]]]\nnp_mat3 = np.array(mat3)\nnp_mat4 = np.array(mat4)\nnp_mat5 = np.array(mat5)\nt0 = time.time()\nm = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat3 = np.array(mat3)\nnp_mat4 = np.array(mat4)\nnp_mat5 = np.array(mat5)\nt0 = time.time()\nm = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat4",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat4 = np.array(mat4)\nnp_mat5 = np.array(mat5)\nt0 = time.time()\nm = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "np_mat5",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "np_mat5 = np.array(mat5)\nt0 = time.time()\nm = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nm = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat3, mat4, axis=3)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat3, mat5, axis=1)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat3, mat5, axis=1)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nnp.concatenate((np_mat3, np_mat4), axis=3)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat3, mat5, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0, \"\\n\")\nt0 = time.time()\nm = cat_matrices(mat3, mat5, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat5), axis=1)\nt1 = time.time()",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nm = cat_matrices(mat3, mat5, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat5), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nm = cat_matrices(mat2, mat5)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat3, mat5, axis=1)\nt1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat5), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nm = cat_matrices(mat2, mat5)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0)\nprint(m)\nt0 = time.time()\nnp.concatenate((np_mat3, np_mat5), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nm = cat_matrices(mat2, mat5)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t0 = time.time()\nnp.concatenate((np_mat3, np_mat5), axis=1)\nt1 = time.time()\nprint(t1 - t0, \"\\n\")\nm = cat_matrices(mat2, mat5)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "t1 = time.time()\nprint(t1 - t0, \"\\n\")\nm = cat_matrices(mat2, mat5)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "math.linear_algebra.102-main",
        "description": "math.linear_algebra.102-main",
        "peekOfCode": "m = cat_matrices(mat2, mat5)\nprint(m)",
        "detail": "math.linear_algebra.102-main",
        "documentation": {}
    },
    {
        "label": "cat_matrices",
        "kind": 2,
        "importPath": "math.linear_algebra.102-squashed_like_sardines",
        "description": "math.linear_algebra.102-squashed_like_sardines",
        "peekOfCode": "def cat_matrices(mat1, mat2, axis=0):\n    \"\"\"A function that concatenates two matrices along a specific axis\"\"\"\n    if axis == 0:\n        if not same_shape(mat1[0], mat2[0]):\n            return None\n        return mat1 + mat2\n    if len(mat1) != len(mat2):\n        return None\n    new_matrix = []\n    for i in range(len(mat1)):",
        "detail": "math.linear_algebra.102-squashed_like_sardines",
        "documentation": {}
    },
    {
        "label": "same_shape",
        "kind": 2,
        "importPath": "math.linear_algebra.102-squashed_like_sardines",
        "description": "math.linear_algebra.102-squashed_like_sardines",
        "peekOfCode": "def same_shape(a, b):\n    \"\"\" Check if two matrices have the same shape (recursively).\"\"\"\n    if type(a) is list and type(b) is list:\n        if len(a) != len(b):\n            return False\n        for i in range(len(a)):\n            if not same_shape(a[i], b[i]):\n                return False\n        return True\n    if type(a) is not list and type(b) is not list:",
        "detail": "math.linear_algebra.102-squashed_like_sardines",
        "documentation": {}
    },
    {
        "label": "np_transpose",
        "kind": 5,
        "importPath": "math.linear_algebra.11-main",
        "description": "math.linear_algebra.11-main",
        "peekOfCode": "np_transpose = __import__('11-the_western_exchange').np_transpose\nmat1 = np.array([1, 2, 3, 4, 5, 6])\nmat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_transpose(mat1))\nprint(mat1)\nprint(np_transpose(mat2))\nprint(mat2)\nprint(np_transpose(mat3))",
        "detail": "math.linear_algebra.11-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.11-main",
        "description": "math.linear_algebra.11-main",
        "peekOfCode": "mat1 = np.array([1, 2, 3, 4, 5, 6])\nmat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_transpose(mat1))\nprint(mat1)\nprint(np_transpose(mat2))\nprint(mat2)\nprint(np_transpose(mat3))\nprint(mat3)",
        "detail": "math.linear_algebra.11-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.11-main",
        "description": "math.linear_algebra.11-main",
        "peekOfCode": "mat2 = np.array([])\nmat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_transpose(mat1))\nprint(mat1)\nprint(np_transpose(mat2))\nprint(mat2)\nprint(np_transpose(mat3))\nprint(mat3)",
        "detail": "math.linear_algebra.11-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.11-main",
        "description": "math.linear_algebra.11-main",
        "peekOfCode": "mat3 = np.array([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],\n                 [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\nprint(np_transpose(mat1))\nprint(mat1)\nprint(np_transpose(mat2))\nprint(mat2)\nprint(np_transpose(mat3))\nprint(mat3)",
        "detail": "math.linear_algebra.11-main",
        "documentation": {}
    },
    {
        "label": "np_transpose",
        "kind": 2,
        "importPath": "math.linear_algebra.11-the_western_exchange",
        "description": "math.linear_algebra.11-the_western_exchange",
        "peekOfCode": "def np_transpose(matrix):\n    \"\"\"A function that transposes matrix\"\"\"\n    return matrix.T",
        "detail": "math.linear_algebra.11-the_western_exchange",
        "documentation": {}
    },
    {
        "label": "np_elementwise",
        "kind": 2,
        "importPath": "math.linear_algebra.12-bracin_the_elements",
        "description": "math.linear_algebra.12-bracin_the_elements",
        "peekOfCode": "def np_elementwise(mat1, mat2):\n    \"\"\" A function that performs element-wise add., sub., multi., and div.\"\"\"\n    return mat1 + mat2, mat1 - mat2, mat1 * mat2, mat1 / mat2",
        "detail": "math.linear_algebra.12-bracin_the_elements",
        "documentation": {}
    },
    {
        "label": "np_elementwise",
        "kind": 5,
        "importPath": "math.linear_algebra.12-main",
        "description": "math.linear_algebra.12-main",
        "peekOfCode": "np_elementwise = __import__('12-bracin_the_elements').np_elementwise\nmat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(mat1)\nprint(mat2)\nadd, sub, mul, div = np_elementwise(mat1, mat2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)\nadd, sub, mul, div = np_elementwise(mat1, 2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)",
        "detail": "math.linear_algebra.12-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.12-main",
        "description": "math.linear_algebra.12-main",
        "peekOfCode": "mat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(mat1)\nprint(mat2)\nadd, sub, mul, div = np_elementwise(mat1, mat2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)\nadd, sub, mul, div = np_elementwise(mat1, 2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)",
        "detail": "math.linear_algebra.12-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.12-main",
        "description": "math.linear_algebra.12-main",
        "peekOfCode": "mat2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(mat1)\nprint(mat2)\nadd, sub, mul, div = np_elementwise(mat1, mat2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)\nadd, sub, mul, div = np_elementwise(mat1, 2)\nprint(\"Add:\\n\", add, \"\\nSub:\\n\", sub, \"\\nMul:\\n\", mul, \"\\nDiv:\\n\", div)",
        "detail": "math.linear_algebra.12-main",
        "documentation": {}
    },
    {
        "label": "np_cat",
        "kind": 2,
        "importPath": "math.linear_algebra.13-cats_got_your_tongue",
        "description": "math.linear_algebra.13-cats_got_your_tongue",
        "peekOfCode": "def np_cat(mat1, mat2, axis=0):\n    \"\"\"A function that concatenates two matrices along a specific axis\"\"\"\n    return np.concatenate((mat1, mat2), axis)",
        "detail": "math.linear_algebra.13-cats_got_your_tongue",
        "documentation": {}
    },
    {
        "label": "np_cat",
        "kind": 5,
        "importPath": "math.linear_algebra.13-main",
        "description": "math.linear_algebra.13-main",
        "peekOfCode": "np_cat = __import__('13-cats_got_your_tongue').np_cat\nmat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6]])\nmat3 = np.array([[7], [8]])\nprint(np_cat(mat1, mat2))\nprint(np_cat(mat1, mat2, axis=1))\nprint(np_cat(mat1, mat3, axis=1))",
        "detail": "math.linear_algebra.13-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.13-main",
        "description": "math.linear_algebra.13-main",
        "peekOfCode": "mat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6]])\nmat3 = np.array([[7], [8]])\nprint(np_cat(mat1, mat2))\nprint(np_cat(mat1, mat2, axis=1))\nprint(np_cat(mat1, mat3, axis=1))",
        "detail": "math.linear_algebra.13-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.13-main",
        "description": "math.linear_algebra.13-main",
        "peekOfCode": "mat2 = np.array([[1, 2, 3], [4, 5, 6]])\nmat3 = np.array([[7], [8]])\nprint(np_cat(mat1, mat2))\nprint(np_cat(mat1, mat2, axis=1))\nprint(np_cat(mat1, mat3, axis=1))",
        "detail": "math.linear_algebra.13-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.13-main",
        "description": "math.linear_algebra.13-main",
        "peekOfCode": "mat3 = np.array([[7], [8]])\nprint(np_cat(mat1, mat2))\nprint(np_cat(mat1, mat2, axis=1))\nprint(np_cat(mat1, mat3, axis=1))",
        "detail": "math.linear_algebra.13-main",
        "documentation": {}
    },
    {
        "label": "np_matmul",
        "kind": 5,
        "importPath": "math.linear_algebra.14-main",
        "description": "math.linear_algebra.14-main",
        "peekOfCode": "np_matmul = __import__('14-saddle_up').np_matmul\nmat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nmat3 = np.array([[7], [8], [9]])\nprint(np_matmul(mat1, mat2))\nprint(np_matmul(mat1, mat3))",
        "detail": "math.linear_algebra.14-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.14-main",
        "description": "math.linear_algebra.14-main",
        "peekOfCode": "mat1 = np.array([[11, 22, 33], [44, 55, 66]])\nmat2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nmat3 = np.array([[7], [8], [9]])\nprint(np_matmul(mat1, mat2))\nprint(np_matmul(mat1, mat3))",
        "detail": "math.linear_algebra.14-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.14-main",
        "description": "math.linear_algebra.14-main",
        "peekOfCode": "mat2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nmat3 = np.array([[7], [8], [9]])\nprint(np_matmul(mat1, mat2))\nprint(np_matmul(mat1, mat3))",
        "detail": "math.linear_algebra.14-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.14-main",
        "description": "math.linear_algebra.14-main",
        "peekOfCode": "mat3 = np.array([[7], [8], [9]])\nprint(np_matmul(mat1, mat2))\nprint(np_matmul(mat1, mat3))",
        "detail": "math.linear_algebra.14-main",
        "documentation": {}
    },
    {
        "label": "np_matmul",
        "kind": 2,
        "importPath": "math.linear_algebra.14-saddle_up",
        "description": "math.linear_algebra.14-saddle_up",
        "peekOfCode": "def np_matmul(mat1, mat2):\n    \"\"\" A function that performs matrix multiplication \"\"\"\n    return (np.matmul(mat1, mat2))",
        "detail": "math.linear_algebra.14-saddle_up",
        "documentation": {}
    },
    {
        "label": "matrix_shape",
        "kind": 5,
        "importPath": "math.linear_algebra.2-main",
        "description": "math.linear_algebra.2-main",
        "peekOfCode": "matrix_shape = __import__('2-size_me_please').matrix_shape\nmat1 = [[1, 2], [3, 4]]\nprint(matrix_shape(mat1))\nmat2 = [[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]],\n        [[16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]]\nprint(matrix_shape(mat2))",
        "detail": "math.linear_algebra.2-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.2-main",
        "description": "math.linear_algebra.2-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nprint(matrix_shape(mat1))\nmat2 = [[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]],\n        [[16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]]\nprint(matrix_shape(mat2))",
        "detail": "math.linear_algebra.2-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.2-main",
        "description": "math.linear_algebra.2-main",
        "peekOfCode": "mat2 = [[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]],\n        [[16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]]\nprint(matrix_shape(mat2))",
        "detail": "math.linear_algebra.2-main",
        "documentation": {}
    },
    {
        "label": "matrix_shape",
        "kind": 2,
        "importPath": "math.linear_algebra.2-size_me_please",
        "description": "math.linear_algebra.2-size_me_please",
        "peekOfCode": "def matrix_shape(matrix):\n    \"\"\"Function that calculates the shape of a matrix\"\"\"\n    matrix_shape = []\n    while type(matrix) is list:\n        matrix_shape.append(len(matrix))\n        matrix = matrix[0]\n    return matrix_shape",
        "detail": "math.linear_algebra.2-size_me_please",
        "documentation": {}
    },
    {
        "label": "matrix_transpose",
        "kind": 2,
        "importPath": "math.linear_algebra.3-flip_me_over",
        "description": "math.linear_algebra.3-flip_me_over",
        "peekOfCode": "def matrix_transpose(matrix):\n    \"\"\"A function that returns the transpose of a 2D matrix\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    transposed = []\n    for i in range(cols):\n        new_row = []\n        for j in range(rows):\n            new_row.append(matrix[j][i])\n        transposed.append(new_row)",
        "detail": "math.linear_algebra.3-flip_me_over",
        "documentation": {}
    },
    {
        "label": "matrix_transpose",
        "kind": 5,
        "importPath": "math.linear_algebra.3-main",
        "description": "math.linear_algebra.3-main",
        "peekOfCode": "matrix_transpose = __import__('3-flip_me_over').matrix_transpose\nmat1 = [[1, 2], [3, 4]]\nprint(mat1)\nprint(matrix_transpose(mat1))\nmat2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]\nprint(mat2)\nprint(matrix_transpose(mat2))",
        "detail": "math.linear_algebra.3-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.3-main",
        "description": "math.linear_algebra.3-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nprint(mat1)\nprint(matrix_transpose(mat1))\nmat2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]\nprint(mat2)\nprint(matrix_transpose(mat2))",
        "detail": "math.linear_algebra.3-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.3-main",
        "description": "math.linear_algebra.3-main",
        "peekOfCode": "mat2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30]]\nprint(mat2)\nprint(matrix_transpose(mat2))",
        "detail": "math.linear_algebra.3-main",
        "documentation": {}
    },
    {
        "label": "add_arrays",
        "kind": 2,
        "importPath": "math.linear_algebra.4-line_up",
        "description": "math.linear_algebra.4-line_up",
        "peekOfCode": "def add_arrays(arr1, arr2):\n    \"\"\" A function that adds two arrays element-wise \"\"\"\n    if len(arr1) != len(arr2):\n        return None\n    result = []\n    for i in range(len(arr1)):\n        sum_elem = arr1[i]+arr2[i]\n        result.append(sum_elem)\n    return result",
        "detail": "math.linear_algebra.4-line_up",
        "documentation": {}
    },
    {
        "label": "add_arrays",
        "kind": 5,
        "importPath": "math.linear_algebra.4-main",
        "description": "math.linear_algebra.4-main",
        "peekOfCode": "add_arrays = __import__('4-line_up').add_arrays\narr1 = [1, 2, 3, 4]\narr2 = [5, 6, 7, 8]\nprint(add_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)\nprint(add_arrays(arr1, [1, 2, 3]))",
        "detail": "math.linear_algebra.4-main",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "math.linear_algebra.4-main",
        "description": "math.linear_algebra.4-main",
        "peekOfCode": "arr1 = [1, 2, 3, 4]\narr2 = [5, 6, 7, 8]\nprint(add_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)\nprint(add_arrays(arr1, [1, 2, 3]))",
        "detail": "math.linear_algebra.4-main",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "math.linear_algebra.4-main",
        "description": "math.linear_algebra.4-main",
        "peekOfCode": "arr2 = [5, 6, 7, 8]\nprint(add_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)\nprint(add_arrays(arr1, [1, 2, 3]))",
        "detail": "math.linear_algebra.4-main",
        "documentation": {}
    },
    {
        "label": "add_matrices2D",
        "kind": 2,
        "importPath": "math.linear_algebra.5-across_the_planes",
        "description": "math.linear_algebra.5-across_the_planes",
        "peekOfCode": "def add_matrices2D(mat1, mat2):\n    \"\"\"A function that adds two matrices element-wise\"\"\"\n    if (len(mat1) != len(mat2)):\n        return None\n    result = []\n    for i in range(len(mat1)):\n        row1 = mat1[i]\n        row2 = mat2[i]\n        if len(row1) != len(row2):\n            return None",
        "detail": "math.linear_algebra.5-across_the_planes",
        "documentation": {}
    },
    {
        "label": "add_matrices2D",
        "kind": 5,
        "importPath": "math.linear_algebra.5-main",
        "description": "math.linear_algebra.5-main",
        "peekOfCode": "add_matrices2D = __import__('5-across_the_planes').add_matrices2D\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices2D(mat1, mat2))\nprint(mat1)\nprint(mat2)\nprint(add_matrices2D(mat1, [[1, 2, 3], [4, 5, 6]]))",
        "detail": "math.linear_algebra.5-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.5-main",
        "description": "math.linear_algebra.5-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6], [7, 8]]\nprint(add_matrices2D(mat1, mat2))\nprint(mat1)\nprint(mat2)\nprint(add_matrices2D(mat1, [[1, 2, 3], [4, 5, 6]]))",
        "detail": "math.linear_algebra.5-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.5-main",
        "description": "math.linear_algebra.5-main",
        "peekOfCode": "mat2 = [[5, 6], [7, 8]]\nprint(add_matrices2D(mat1, mat2))\nprint(mat1)\nprint(mat2)\nprint(add_matrices2D(mat1, [[1, 2, 3], [4, 5, 6]]))",
        "detail": "math.linear_algebra.5-main",
        "documentation": {}
    },
    {
        "label": "cat_arrays",
        "kind": 2,
        "importPath": "math.linear_algebra.6-howdy_partner",
        "description": "math.linear_algebra.6-howdy_partner",
        "peekOfCode": "def cat_arrays(arr1, arr2):\n    \"\"\"A function that concatenates two arrays\"\"\"\n    return arr1 + arr2",
        "detail": "math.linear_algebra.6-howdy_partner",
        "documentation": {}
    },
    {
        "label": "cat_arrays",
        "kind": 5,
        "importPath": "math.linear_algebra.6-main",
        "description": "math.linear_algebra.6-main",
        "peekOfCode": "cat_arrays = __import__('6-howdy_partner').cat_arrays\narr1 = [1, 2, 3, 4, 5]\narr2 = [6, 7, 8]\nprint(cat_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)",
        "detail": "math.linear_algebra.6-main",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "math.linear_algebra.6-main",
        "description": "math.linear_algebra.6-main",
        "peekOfCode": "arr1 = [1, 2, 3, 4, 5]\narr2 = [6, 7, 8]\nprint(cat_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)",
        "detail": "math.linear_algebra.6-main",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "math.linear_algebra.6-main",
        "description": "math.linear_algebra.6-main",
        "peekOfCode": "arr2 = [6, 7, 8]\nprint(cat_arrays(arr1, arr2))\nprint(arr1)\nprint(arr2)",
        "detail": "math.linear_algebra.6-main",
        "documentation": {}
    },
    {
        "label": "cat_matrices2D",
        "kind": 2,
        "importPath": "math.linear_algebra.7-gettin_cozy",
        "description": "math.linear_algebra.7-gettin_cozy",
        "peekOfCode": "def cat_matrices2D(mat1, mat2, axis=0):\n    \"\"\" A function that concatenates two matrices along a specific axis\"\"\"\n    if not mat1 or not mat2:\n        return None\n    if axis == 0:\n        for row in mat1:\n            if len(row) != len(mat1[0]):\n                return None\n        for row in mat2:\n            if len(row) != len(mat2[0]):",
        "detail": "math.linear_algebra.7-gettin_cozy",
        "documentation": {}
    },
    {
        "label": "cat_matrices2D",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "cat_matrices2D = __import__('7-gettin_cozy').cat_matrices2D\nmat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6]]\nmat3 = [[7], [8]]\nmat4 = cat_matrices2D(mat1, mat2)\nmat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat1 = [[1, 2], [3, 4]]\nmat2 = [[5, 6]]\nmat3 = [[7], [8]]\nmat4 = cat_matrices2D(mat1, mat2)\nmat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat2 = [[5, 6]]\nmat3 = [[7], [8]]\nmat4 = cat_matrices2D(mat1, mat2)\nmat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)\nprint(mat4)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat3 = [[7], [8]]\nmat4 = cat_matrices2D(mat1, mat2)\nmat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)\nprint(mat4)\nprint(mat5)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat4",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat4 = cat_matrices2D(mat1, mat2)\nmat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)\nprint(mat4)\nprint(mat5)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat5",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat5 = cat_matrices2D(mat1, mat3, axis=1)\nprint(mat4)\nprint(mat5)\nmat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)\nprint(mat4)\nprint(mat5)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat1[0]",
        "kind": 5,
        "importPath": "math.linear_algebra.7-main",
        "description": "math.linear_algebra.7-main",
        "peekOfCode": "mat1[0] = [9, 10]\nmat1[1].append(5)\nprint(mat1)\nprint(mat4)\nprint(mat5)",
        "detail": "math.linear_algebra.7-main",
        "documentation": {}
    },
    {
        "label": "mat_mul",
        "kind": 5,
        "importPath": "math.linear_algebra.8-main",
        "description": "math.linear_algebra.8-main",
        "peekOfCode": "mat_mul = __import__('8-ridin_bareback').mat_mul\nmat1 = [[1, 2],\n        [3, 4],\n        [5, 6]]\nmat2 = [[1, 2, 3, 4],\n        [5, 6, 7, 8]]\nprint(mat_mul(mat1, mat2))",
        "detail": "math.linear_algebra.8-main",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.8-main",
        "description": "math.linear_algebra.8-main",
        "peekOfCode": "mat1 = [[1, 2],\n        [3, 4],\n        [5, 6]]\nmat2 = [[1, 2, 3, 4],\n        [5, 6, 7, 8]]\nprint(mat_mul(mat1, mat2))",
        "detail": "math.linear_algebra.8-main",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.8-main",
        "description": "math.linear_algebra.8-main",
        "peekOfCode": "mat2 = [[1, 2, 3, 4],\n        [5, 6, 7, 8]]\nprint(mat_mul(mat1, mat2))",
        "detail": "math.linear_algebra.8-main",
        "documentation": {}
    },
    {
        "label": "mat_mul",
        "kind": 2,
        "importPath": "math.linear_algebra.8-ridin_bareback",
        "description": "math.linear_algebra.8-ridin_bareback",
        "peekOfCode": "def mat_mul(mat1, mat2):\n    \"\"\"A function that performs matrix multiplication\"\"\"\n    if len(mat1[0]) != len(mat2):\n        return None\n    result = []\n    for i in range(len(mat1)):\n        row = []\n        for j in range(len(mat2[0])):\n            row.append(0)\n        result.append(row)",
        "detail": "math.linear_algebra.8-ridin_bareback",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "math.linear_algebra.9-let_the_butcher_slice_it",
        "description": "math.linear_algebra.9-let_the_butcher_slice_it",
        "peekOfCode": "matrix = np.array([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12],\n                   [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24]])\nmat1 = matrix[1:3, :]\nmat2 = matrix[:, 2:4]\nmat3 = matrix[1:, 3:]\nprint(\"The middle two rows of the matrix are:\\n{}\".format(mat1))\nprint(\"The middle two columns of the matrix are:\\n{}\".format(mat2))\nprint(\"The bottom-right, square, 3x3 matrix is:\\n{}\".format(mat3))",
        "detail": "math.linear_algebra.9-let_the_butcher_slice_it",
        "documentation": {}
    },
    {
        "label": "mat1",
        "kind": 5,
        "importPath": "math.linear_algebra.9-let_the_butcher_slice_it",
        "description": "math.linear_algebra.9-let_the_butcher_slice_it",
        "peekOfCode": "mat1 = matrix[1:3, :]\nmat2 = matrix[:, 2:4]\nmat3 = matrix[1:, 3:]\nprint(\"The middle two rows of the matrix are:\\n{}\".format(mat1))\nprint(\"The middle two columns of the matrix are:\\n{}\".format(mat2))\nprint(\"The bottom-right, square, 3x3 matrix is:\\n{}\".format(mat3))",
        "detail": "math.linear_algebra.9-let_the_butcher_slice_it",
        "documentation": {}
    },
    {
        "label": "mat2",
        "kind": 5,
        "importPath": "math.linear_algebra.9-let_the_butcher_slice_it",
        "description": "math.linear_algebra.9-let_the_butcher_slice_it",
        "peekOfCode": "mat2 = matrix[:, 2:4]\nmat3 = matrix[1:, 3:]\nprint(\"The middle two rows of the matrix are:\\n{}\".format(mat1))\nprint(\"The middle two columns of the matrix are:\\n{}\".format(mat2))\nprint(\"The bottom-right, square, 3x3 matrix is:\\n{}\".format(mat3))",
        "detail": "math.linear_algebra.9-let_the_butcher_slice_it",
        "documentation": {}
    },
    {
        "label": "mat3",
        "kind": 5,
        "importPath": "math.linear_algebra.9-let_the_butcher_slice_it",
        "description": "math.linear_algebra.9-let_the_butcher_slice_it",
        "peekOfCode": "mat3 = matrix[1:, 3:]\nprint(\"The middle two rows of the matrix are:\\n{}\".format(mat1))\nprint(\"The middle two columns of the matrix are:\\n{}\".format(mat2))\nprint(\"The bottom-right, square, 3x3 matrix is:\\n{}\".format(mat3))",
        "detail": "math.linear_algebra.9-let_the_butcher_slice_it",
        "documentation": {}
    },
    {
        "label": "line",
        "kind": 2,
        "importPath": "math.plotting.0-line",
        "description": "math.plotting.0-line",
        "peekOfCode": "def line():\n    \"\"\" A function that plot y as a line graph\"\"\"\n    y = np.arange(0, 11) ** 3\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here\n    plt.plot(y, color='red')\n    plt.xlim(0, 10)\n    plt.show()",
        "detail": "math.plotting.0-line",
        "documentation": {}
    },
    {
        "label": "scatter",
        "kind": 2,
        "importPath": "math.plotting.1-scatter",
        "description": "math.plotting.1-scatter",
        "peekOfCode": "def scatter():\n    \"\"\" A function that plot x  y as a scatter plot\"\"\"\n    mean = [69, 0]\n    cov = [[15, 8], [8, 15]]\n    np.random.seed(5)\n    x, y = np.random.multivariate_normal(mean, cov, 2000).T\n    y += 180\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here\n    plt.scatter(x, y, color='magenta')",
        "detail": "math.plotting.1-scatter",
        "documentation": {}
    },
    {
        "label": "gradient",
        "kind": 2,
        "importPath": "math.plotting.100-gradient",
        "description": "math.plotting.100-gradient",
        "peekOfCode": "def gradient():\n    \"\"\"\n    A function that create a scatter plot\n    of sampled elevations on a mountain\n    \"\"\"\n    np.random.seed(5)\n    x = np.random.randn(2000) * 10\n    y = np.random.randn(2000) * 10\n    z = np.random.rand(2000) + 40 - np.sqrt(np.square(x) + np.square(y))\n    plt.figure(figsize=(6.4, 4.8))",
        "detail": "math.plotting.100-gradient",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "lib = np.load(\"pca.npz\")\ndata = lib[\"data\"]\nlabels = lib[\"labels\"]\ndata_means = np.mean(data, axis=0)\nnorm_data = data - data_means\n_, _, Vh = np.linalg.svd(norm_data)\npca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "data = lib[\"data\"]\nlabels = lib[\"labels\"]\ndata_means = np.mean(data, axis=0)\nnorm_data = data - data_means\n_, _, Vh = np.linalg.svd(norm_data)\npca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "labels = lib[\"labels\"]\ndata_means = np.mean(data, axis=0)\nnorm_data = data - data_means\n_, _, Vh = np.linalg.svd(norm_data)\npca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "data_means",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "data_means = np.mean(data, axis=0)\nnorm_data = data - data_means\n_, _, Vh = np.linalg.svd(norm_data)\npca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "norm_data",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "norm_data = data - data_means\n_, _, Vh = np.linalg.svd(norm_data)\npca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],\n    pca_data[:, 2],",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "pca_data",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "pca_data = np.matmul(norm_data, Vh[:3].T)\n# your code here\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],\n    pca_data[:, 2],\n    c=labels,\n    cmap=\"plasma\",",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "fig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],\n    pca_data[:, 2],\n    c=labels,\n    cmap=\"plasma\",\n    s=50,\n    edgecolor=\"k\"",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "ax = fig.add_subplot(111, projection=\"3d\")\nsc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],\n    pca_data[:, 2],\n    c=labels,\n    cmap=\"plasma\",\n    s=50,\n    edgecolor=\"k\"\n)",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "sc",
        "kind": 5,
        "importPath": "math.plotting.101-pca",
        "description": "math.plotting.101-pca",
        "peekOfCode": "sc = ax.scatter(\n    pca_data[:, 0],\n    pca_data[:, 1],\n    pca_data[:, 2],\n    c=labels,\n    cmap=\"plasma\",\n    s=50,\n    edgecolor=\"k\"\n)\nax.set_xlabel(\"U1\", fontsize=10)",
        "detail": "math.plotting.101-pca",
        "documentation": {}
    },
    {
        "label": "change_scale",
        "kind": 2,
        "importPath": "math.plotting.2-change_scale",
        "description": "math.plotting.2-change_scale",
        "peekOfCode": "def change_scale():\n    \"\"\" A function that plot x  y as a line graph\"\"\"\n    x = np.arange(0, 28651, 5730)\n    r = np.log(0.5)\n    t = 5730\n    y = np.exp((r / t) * x)\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here\n    plt.plot(x, y)\n    plt.yscale(\"log\")",
        "detail": "math.plotting.2-change_scale",
        "documentation": {}
    },
    {
        "label": "two",
        "kind": 2,
        "importPath": "math.plotting.3-two",
        "description": "math.plotting.3-two",
        "peekOfCode": "def two():\n    \"\"\" A function that plot x  y1 and x  y2 as line graphs\"\"\"\n    x = np.arange(0, 21000, 1000)\n    r = np.log(0.5)\n    t1 = 5730\n    t2 = 1600\n    y1 = np.exp((r / t1) * x)\n    y2 = np.exp((r / t2) * x)\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here",
        "detail": "math.plotting.3-two",
        "documentation": {}
    },
    {
        "label": "frequency",
        "kind": 2,
        "importPath": "math.plotting.4-frequency",
        "description": "math.plotting.4-frequency",
        "peekOfCode": "def frequency():\n    \"\"\" A function that plot a histogram of student scores for a project\"\"\"\n    np.random.seed(5)\n    student_grades = np.random.normal(68, 15, 50)\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here\n    plt.hist(student_grades, bins=10, range=(0, 100), edgecolor='black')\n    plt.title('Project A')\n    plt.xlabel('Grades')\n    plt.ylabel('Number of Students')",
        "detail": "math.plotting.4-frequency",
        "documentation": {}
    },
    {
        "label": "all_in_one",
        "kind": 2,
        "importPath": "math.plotting.5-all_in_one",
        "description": "math.plotting.5-all_in_one",
        "peekOfCode": "def all_in_one():\n    \"\"\" A function that plot all 5 sub graphs in one figure\"\"\"\n    y0 = np.arange(0, 11) ** 3\n    mean = [69, 0]\n    cov = [[15, 8], [8, 15]]\n    np.random.seed(5)\n    x1, y1 = np.random.multivariate_normal(mean, cov, 2000).T\n    y1 += 180\n    x2 = np.arange(0, 28651, 5730)\n    r2 = np.log(0.5)",
        "detail": "math.plotting.5-all_in_one",
        "documentation": {}
    },
    {
        "label": "bars",
        "kind": 2,
        "importPath": "math.plotting.6-bars",
        "description": "math.plotting.6-bars",
        "peekOfCode": "def bars():\n    \"\"\" A function plot a stacked bar graph\"\"\"\n    np.random.seed(5)\n    fruit = np.random.randint(0, 20, (4, 3))\n    plt.figure(figsize=(6.4, 4.8))\n    # your code here\n    x = ['Farrah', 'Fred', 'Felicia']\n    plt.bar(x, fruit[0], color='red', label='apples', width=0.5)\n    plt.bar(x, fruit[1], bottom=fruit[0], color='yellow', label='bananas',\n            width=0.5)",
        "detail": "math.plotting.6-bars",
        "documentation": {}
    },
    {
        "label": "Poisson",
        "kind": 5,
        "importPath": "math.probability.0-main",
        "description": "math.probability.0-main",
        "peekOfCode": "Poisson = __import__('poisson').Poisson\nnp.random.seed(0)\ndata = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('Lambtha:', p1.lambtha)\np2 = Poisson(lambtha=5)\nprint('Lambtha:', p2.lambtha)",
        "detail": "math.probability.0-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.0-main",
        "description": "math.probability.0-main",
        "peekOfCode": "data = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('Lambtha:', p1.lambtha)\np2 = Poisson(lambtha=5)\nprint('Lambtha:', p2.lambtha)",
        "detail": "math.probability.0-main",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "math.probability.0-main",
        "description": "math.probability.0-main",
        "peekOfCode": "p1 = Poisson(data)\nprint('Lambtha:', p1.lambtha)\np2 = Poisson(lambtha=5)\nprint('Lambtha:', p2.lambtha)",
        "detail": "math.probability.0-main",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "math.probability.0-main",
        "description": "math.probability.0-main",
        "peekOfCode": "p2 = Poisson(lambtha=5)\nprint('Lambtha:', p2.lambtha)",
        "detail": "math.probability.0-main",
        "documentation": {}
    },
    {
        "label": "Poisson",
        "kind": 5,
        "importPath": "math.probability.1-main",
        "description": "math.probability.1-main",
        "peekOfCode": "Poisson = __import__('poisson').Poisson\nnp.random.seed(0)\ndata = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('P(9):', p1.pmf(9))\np2 = Poisson(lambtha=5)\nprint('P(9):', p2.pmf(9))",
        "detail": "math.probability.1-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.1-main",
        "description": "math.probability.1-main",
        "peekOfCode": "data = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('P(9):', p1.pmf(9))\np2 = Poisson(lambtha=5)\nprint('P(9):', p2.pmf(9))",
        "detail": "math.probability.1-main",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "math.probability.1-main",
        "description": "math.probability.1-main",
        "peekOfCode": "p1 = Poisson(data)\nprint('P(9):', p1.pmf(9))\np2 = Poisson(lambtha=5)\nprint('P(9):', p2.pmf(9))",
        "detail": "math.probability.1-main",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "math.probability.1-main",
        "description": "math.probability.1-main",
        "peekOfCode": "p2 = Poisson(lambtha=5)\nprint('P(9):', p2.pmf(9))",
        "detail": "math.probability.1-main",
        "documentation": {}
    },
    {
        "label": "Binomial",
        "kind": 5,
        "importPath": "math.probability.10-main",
        "description": "math.probability.10-main",
        "peekOfCode": "Binomial = __import__('binomial').Binomial\nnp.random.seed(0)\ndata = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('n:', b1.n, \"p:\", b1.p)\nb2 = Binomial(n=50, p=0.6)\nprint('n:', b2.n, \"p:\", b2.p)",
        "detail": "math.probability.10-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.10-main",
        "description": "math.probability.10-main",
        "peekOfCode": "data = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('n:', b1.n, \"p:\", b1.p)\nb2 = Binomial(n=50, p=0.6)\nprint('n:', b2.n, \"p:\", b2.p)",
        "detail": "math.probability.10-main",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "math.probability.10-main",
        "description": "math.probability.10-main",
        "peekOfCode": "b1 = Binomial(data)\nprint('n:', b1.n, \"p:\", b1.p)\nb2 = Binomial(n=50, p=0.6)\nprint('n:', b2.n, \"p:\", b2.p)",
        "detail": "math.probability.10-main",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "math.probability.10-main",
        "description": "math.probability.10-main",
        "peekOfCode": "b2 = Binomial(n=50, p=0.6)\nprint('n:', b2.n, \"p:\", b2.p)",
        "detail": "math.probability.10-main",
        "documentation": {}
    },
    {
        "label": "Binomial",
        "kind": 5,
        "importPath": "math.probability.11-main",
        "description": "math.probability.11-main",
        "peekOfCode": "Binomial = __import__('binomial').Binomial\nnp.random.seed(0)\ndata = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('P(30):', b1.pmf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('P(30):', b2.pmf(30))",
        "detail": "math.probability.11-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.11-main",
        "description": "math.probability.11-main",
        "peekOfCode": "data = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('P(30):', b1.pmf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('P(30):', b2.pmf(30))",
        "detail": "math.probability.11-main",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "math.probability.11-main",
        "description": "math.probability.11-main",
        "peekOfCode": "b1 = Binomial(data)\nprint('P(30):', b1.pmf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('P(30):', b2.pmf(30))",
        "detail": "math.probability.11-main",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "math.probability.11-main",
        "description": "math.probability.11-main",
        "peekOfCode": "b2 = Binomial(n=50, p=0.6)\nprint('P(30):', b2.pmf(30))",
        "detail": "math.probability.11-main",
        "documentation": {}
    },
    {
        "label": "Binomial",
        "kind": 5,
        "importPath": "math.probability.12-main",
        "description": "math.probability.12-main",
        "peekOfCode": "Binomial = __import__('binomial').Binomial\nnp.random.seed(0)\ndata = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('F(30):', b1.cdf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('F(30):', b2.cdf(30))",
        "detail": "math.probability.12-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.12-main",
        "description": "math.probability.12-main",
        "peekOfCode": "data = np.random.binomial(50, 0.6, 100).tolist()\nb1 = Binomial(data)\nprint('F(30):', b1.cdf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('F(30):', b2.cdf(30))",
        "detail": "math.probability.12-main",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "math.probability.12-main",
        "description": "math.probability.12-main",
        "peekOfCode": "b1 = Binomial(data)\nprint('F(30):', b1.cdf(30))\nb2 = Binomial(n=50, p=0.6)\nprint('F(30):', b2.cdf(30))",
        "detail": "math.probability.12-main",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "math.probability.12-main",
        "description": "math.probability.12-main",
        "peekOfCode": "b2 = Binomial(n=50, p=0.6)\nprint('F(30):', b2.cdf(30))",
        "detail": "math.probability.12-main",
        "documentation": {}
    },
    {
        "label": "Poisson",
        "kind": 5,
        "importPath": "math.probability.2-main",
        "description": "math.probability.2-main",
        "peekOfCode": "Poisson = __import__('poisson').Poisson\nnp.random.seed(0)\ndata = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('F(9):', p1.cdf(9))\np2 = Poisson(lambtha=5)\nprint('F(9):', p2.cdf(9))",
        "detail": "math.probability.2-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.2-main",
        "description": "math.probability.2-main",
        "peekOfCode": "data = np.random.poisson(5., 100).tolist()\np1 = Poisson(data)\nprint('F(9):', p1.cdf(9))\np2 = Poisson(lambtha=5)\nprint('F(9):', p2.cdf(9))",
        "detail": "math.probability.2-main",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "math.probability.2-main",
        "description": "math.probability.2-main",
        "peekOfCode": "p1 = Poisson(data)\nprint('F(9):', p1.cdf(9))\np2 = Poisson(lambtha=5)\nprint('F(9):', p2.cdf(9))",
        "detail": "math.probability.2-main",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "math.probability.2-main",
        "description": "math.probability.2-main",
        "peekOfCode": "p2 = Poisson(lambtha=5)\nprint('F(9):', p2.cdf(9))",
        "detail": "math.probability.2-main",
        "documentation": {}
    },
    {
        "label": "Exponential",
        "kind": 5,
        "importPath": "math.probability.3-main",
        "description": "math.probability.3-main",
        "peekOfCode": "Exponential = __import__('exponential').Exponential\nnp.random.seed(0)\ndata = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('Lambtha:', e1.lambtha)\ne2 = Exponential(lambtha=2)\nprint('Lambtha:', e2.lambtha)",
        "detail": "math.probability.3-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.3-main",
        "description": "math.probability.3-main",
        "peekOfCode": "data = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('Lambtha:', e1.lambtha)\ne2 = Exponential(lambtha=2)\nprint('Lambtha:', e2.lambtha)",
        "detail": "math.probability.3-main",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "math.probability.3-main",
        "description": "math.probability.3-main",
        "peekOfCode": "e1 = Exponential(data)\nprint('Lambtha:', e1.lambtha)\ne2 = Exponential(lambtha=2)\nprint('Lambtha:', e2.lambtha)",
        "detail": "math.probability.3-main",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "math.probability.3-main",
        "description": "math.probability.3-main",
        "peekOfCode": "e2 = Exponential(lambtha=2)\nprint('Lambtha:', e2.lambtha)",
        "detail": "math.probability.3-main",
        "documentation": {}
    },
    {
        "label": "Exponential",
        "kind": 5,
        "importPath": "math.probability.4-main",
        "description": "math.probability.4-main",
        "peekOfCode": "Exponential = __import__('exponential').Exponential\nnp.random.seed(0)\ndata = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('f(1):', e1.pdf(1))\ne2 = Exponential(lambtha=2)\nprint('f(1):', e2.pdf(1))",
        "detail": "math.probability.4-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.4-main",
        "description": "math.probability.4-main",
        "peekOfCode": "data = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('f(1):', e1.pdf(1))\ne2 = Exponential(lambtha=2)\nprint('f(1):', e2.pdf(1))",
        "detail": "math.probability.4-main",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "math.probability.4-main",
        "description": "math.probability.4-main",
        "peekOfCode": "e1 = Exponential(data)\nprint('f(1):', e1.pdf(1))\ne2 = Exponential(lambtha=2)\nprint('f(1):', e2.pdf(1))",
        "detail": "math.probability.4-main",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "math.probability.4-main",
        "description": "math.probability.4-main",
        "peekOfCode": "e2 = Exponential(lambtha=2)\nprint('f(1):', e2.pdf(1))",
        "detail": "math.probability.4-main",
        "documentation": {}
    },
    {
        "label": "Exponential",
        "kind": 5,
        "importPath": "math.probability.5-main",
        "description": "math.probability.5-main",
        "peekOfCode": "Exponential = __import__('exponential').Exponential\nnp.random.seed(0)\ndata = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('F(1):', e1.cdf(1))\ne2 = Exponential(lambtha=2)\nprint('F(1):', e2.cdf(1))",
        "detail": "math.probability.5-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.5-main",
        "description": "math.probability.5-main",
        "peekOfCode": "data = np.random.exponential(0.5, 100).tolist()\ne1 = Exponential(data)\nprint('F(1):', e1.cdf(1))\ne2 = Exponential(lambtha=2)\nprint('F(1):', e2.cdf(1))",
        "detail": "math.probability.5-main",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "math.probability.5-main",
        "description": "math.probability.5-main",
        "peekOfCode": "e1 = Exponential(data)\nprint('F(1):', e1.cdf(1))\ne2 = Exponential(lambtha=2)\nprint('F(1):', e2.cdf(1))",
        "detail": "math.probability.5-main",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "math.probability.5-main",
        "description": "math.probability.5-main",
        "peekOfCode": "e2 = Exponential(lambtha=2)\nprint('F(1):', e2.cdf(1))",
        "detail": "math.probability.5-main",
        "documentation": {}
    },
    {
        "label": "Normal",
        "kind": 5,
        "importPath": "math.probability.6-main",
        "description": "math.probability.6-main",
        "peekOfCode": "Normal = __import__('normal').Normal\nnp.random.seed(0)\ndata = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('Mean:', n1.mean, ', Stddev:', n1.stddev)\nn2 = Normal(mean=70, stddev=10)\nprint('Mean:', n2.mean, ', Stddev:', n2.stddev)",
        "detail": "math.probability.6-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.6-main",
        "description": "math.probability.6-main",
        "peekOfCode": "data = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('Mean:', n1.mean, ', Stddev:', n1.stddev)\nn2 = Normal(mean=70, stddev=10)\nprint('Mean:', n2.mean, ', Stddev:', n2.stddev)",
        "detail": "math.probability.6-main",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "math.probability.6-main",
        "description": "math.probability.6-main",
        "peekOfCode": "n1 = Normal(data)\nprint('Mean:', n1.mean, ', Stddev:', n1.stddev)\nn2 = Normal(mean=70, stddev=10)\nprint('Mean:', n2.mean, ', Stddev:', n2.stddev)",
        "detail": "math.probability.6-main",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "math.probability.6-main",
        "description": "math.probability.6-main",
        "peekOfCode": "n2 = Normal(mean=70, stddev=10)\nprint('Mean:', n2.mean, ', Stddev:', n2.stddev)",
        "detail": "math.probability.6-main",
        "documentation": {}
    },
    {
        "label": "Normal",
        "kind": 5,
        "importPath": "math.probability.7-main",
        "description": "math.probability.7-main",
        "peekOfCode": "Normal = __import__('normal').Normal\nnp.random.seed(0)\ndata = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('Z(90):', n1.z_score(90))\nprint('X(2):', n1.x_value(2))\nn2 = Normal(mean=70, stddev=10)\nprint()\nprint('Z(90):', n2.z_score(90))\nprint('X(2):', n2.x_value(2))",
        "detail": "math.probability.7-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.7-main",
        "description": "math.probability.7-main",
        "peekOfCode": "data = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('Z(90):', n1.z_score(90))\nprint('X(2):', n1.x_value(2))\nn2 = Normal(mean=70, stddev=10)\nprint()\nprint('Z(90):', n2.z_score(90))\nprint('X(2):', n2.x_value(2))",
        "detail": "math.probability.7-main",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "math.probability.7-main",
        "description": "math.probability.7-main",
        "peekOfCode": "n1 = Normal(data)\nprint('Z(90):', n1.z_score(90))\nprint('X(2):', n1.x_value(2))\nn2 = Normal(mean=70, stddev=10)\nprint()\nprint('Z(90):', n2.z_score(90))\nprint('X(2):', n2.x_value(2))",
        "detail": "math.probability.7-main",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "math.probability.7-main",
        "description": "math.probability.7-main",
        "peekOfCode": "n2 = Normal(mean=70, stddev=10)\nprint()\nprint('Z(90):', n2.z_score(90))\nprint('X(2):', n2.x_value(2))",
        "detail": "math.probability.7-main",
        "documentation": {}
    },
    {
        "label": "Normal",
        "kind": 5,
        "importPath": "math.probability.8-main",
        "description": "math.probability.8-main",
        "peekOfCode": "Normal = __import__('normal').Normal\nnp.random.seed(0)\ndata = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('PSI(90):', n1.pdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PSI(90):', n2.pdf(90))",
        "detail": "math.probability.8-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.8-main",
        "description": "math.probability.8-main",
        "peekOfCode": "data = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('PSI(90):', n1.pdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PSI(90):', n2.pdf(90))",
        "detail": "math.probability.8-main",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "math.probability.8-main",
        "description": "math.probability.8-main",
        "peekOfCode": "n1 = Normal(data)\nprint('PSI(90):', n1.pdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PSI(90):', n2.pdf(90))",
        "detail": "math.probability.8-main",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "math.probability.8-main",
        "description": "math.probability.8-main",
        "peekOfCode": "n2 = Normal(mean=70, stddev=10)\nprint('PSI(90):', n2.pdf(90))",
        "detail": "math.probability.8-main",
        "documentation": {}
    },
    {
        "label": "Normal",
        "kind": 5,
        "importPath": "math.probability.9-main",
        "description": "math.probability.9-main",
        "peekOfCode": "Normal = __import__('normal').Normal\nnp.random.seed(0)\ndata = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('PHI(90):', n1.cdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PHI(90):', n2.cdf(90))",
        "detail": "math.probability.9-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "math.probability.9-main",
        "description": "math.probability.9-main",
        "peekOfCode": "data = np.random.normal(70, 10, 100).tolist()\nn1 = Normal(data)\nprint('PHI(90):', n1.cdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PHI(90):', n2.cdf(90))",
        "detail": "math.probability.9-main",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "math.probability.9-main",
        "description": "math.probability.9-main",
        "peekOfCode": "n1 = Normal(data)\nprint('PHI(90):', n1.cdf(90))\nn2 = Normal(mean=70, stddev=10)\nprint('PHI(90):', n2.cdf(90))",
        "detail": "math.probability.9-main",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "math.probability.9-main",
        "description": "math.probability.9-main",
        "peekOfCode": "n2 = Normal(mean=70, stddev=10)\nprint('PHI(90):', n2.cdf(90))",
        "detail": "math.probability.9-main",
        "documentation": {}
    },
    {
        "label": "Binomial",
        "kind": 6,
        "importPath": "math.probability.binomial",
        "description": "math.probability.binomial",
        "peekOfCode": "class Binomial:\n    \"\"\" Class with constructor for a Binomial distribution\"\"\"\n    def __init__(self, data=None, n=1, p=0.5):\n        \"\"\"\n        A class that represents a Binomial distribution\n        \"\"\"\n        if data is None:\n            if n <= 0:\n                raise ValueError(\"n must be a positive value\")\n            if p <= 0 or p >= 1:",
        "detail": "math.probability.binomial",
        "documentation": {}
    },
    {
        "label": "Exponential",
        "kind": 6,
        "importPath": "math.probability.exponential",
        "description": "math.probability.exponential",
        "peekOfCode": "class Exponential:\n    \"\"\"A class that represents an exponential distribution:\"\"\"\n    def __init__(self, data=None, lambtha=1.):\n        \"\"\"Class constructor\"\"\"\n        if data is None:\n            if lambtha <= 0:\n                raise ValueError(\"lambtha must be a positive value\")\n            self.lambtha = float(lambtha)\n        else:\n            if type(data) is not list:",
        "detail": "math.probability.exponential",
        "documentation": {}
    },
    {
        "label": "Normal",
        "kind": 6,
        "importPath": "math.probability.normal",
        "description": "math.probability.normal",
        "peekOfCode": "class Normal:\n    \"\"\"A class that represents a Normal distribution\"\"\"\n    def __init__(self, data=None, mean=0., stddev=1.):\n        \"\"\"A function that initializes a Normal distribution instance\"\"\"\n        if data is None:\n            if stddev <= 0:\n                raise ValueError(\"stddev must be a positive value\")\n            self.mean = float(mean)\n            self.stddev = float(stddev)\n        else:",
        "detail": "math.probability.normal",
        "documentation": {}
    },
    {
        "label": "Poisson",
        "kind": 6,
        "importPath": "math.probability.poisson",
        "description": "math.probability.poisson",
        "peekOfCode": "class Poisson:\n    \"\"\"class that represents Poisson distribution\"\"\"\n    def __init__(self, data=None, lambtha=1.):\n        \"\"\"class constructor\"\"\"\n        if data is None:\n            if lambtha < 1:\n                raise ValueError(\"lambtha must be a positive value\")\n            else:\n                self.lambtha = float(lambtha)\n        else:",
        "detail": "math.probability.poisson",
        "documentation": {}
    },
    {
        "label": "availableShips",
        "kind": 5,
        "importPath": "pipeline.apis.0-main",
        "description": "pipeline.apis.0-main",
        "peekOfCode": "availableShips = __import__('0-passengers').availableShips\nships = availableShips(4)\nfor ship in ships:\n    print(ship)",
        "detail": "pipeline.apis.0-main",
        "documentation": {}
    },
    {
        "label": "ships",
        "kind": 5,
        "importPath": "pipeline.apis.0-main",
        "description": "pipeline.apis.0-main",
        "peekOfCode": "ships = availableShips(4)\nfor ship in ships:\n    print(ship)",
        "detail": "pipeline.apis.0-main",
        "documentation": {}
    },
    {
        "label": "availableShips",
        "kind": 2,
        "importPath": "pipeline.apis.0-passengers",
        "description": "pipeline.apis.0-passengers",
        "peekOfCode": "def availableShips(passengerCount):\n    \"\"\"\n    A function that returns the list of ships that can hold\n    a given number of passengers\n    \"\"\"\n    data = requests.get(\"https://swapi-api.hbtn.io/api/starships\").json()\n    availableShips = []\n    while data.get(\"next\") is not None:\n        starships = data.get(\"results\")\n        for starship in starships:",
        "detail": "pipeline.apis.0-passengers",
        "documentation": {}
    },
    {
        "label": "sentientPlanets",
        "kind": 5,
        "importPath": "pipeline.apis.1-main",
        "description": "pipeline.apis.1-main",
        "peekOfCode": "sentientPlanets = __import__('1-sentience').sentientPlanets\nplanets = sentientPlanets()\nfor planet in planets:\n    print(planet)",
        "detail": "pipeline.apis.1-main",
        "documentation": {}
    },
    {
        "label": "planets",
        "kind": 5,
        "importPath": "pipeline.apis.1-main",
        "description": "pipeline.apis.1-main",
        "peekOfCode": "planets = sentientPlanets()\nfor planet in planets:\n    print(planet)",
        "detail": "pipeline.apis.1-main",
        "documentation": {}
    },
    {
        "label": "sentientPlanets",
        "kind": 2,
        "importPath": "pipeline.apis.1-sentience",
        "description": "pipeline.apis.1-sentience",
        "peekOfCode": "def sentientPlanets():\n    \"\"\"\n    A function that returns the list of names of the\n    home planets of all sentient species\n    \"\"\"\n    url = \"https://swapi-api.hbtn.io/api/species\"\n    sentient_planets = []\n    while url is not None:\n        data = requests.get(url).json()\n        species = data.get(\"results\")",
        "detail": "pipeline.apis.1-sentience",
        "documentation": {}
    },
    {
        "label": "from_numpy",
        "kind": 2,
        "importPath": "pipeline.pandas.0-from_numpy",
        "description": "pipeline.pandas.0-from_numpy",
        "peekOfCode": "def from_numpy(array):\n    '''A function that creates a pd.DataFrame from a np.ndarray'''\n    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    num_columns = array.shape[1]\n    column_names = list(letters[:num_columns])\n    df = pd.DataFrame(array, columns=column_names)\n    return df",
        "detail": "pipeline.pandas.0-from_numpy",
        "documentation": {}
    },
    {
        "label": "from_numpy",
        "kind": 5,
        "importPath": "pipeline.pandas.0-main",
        "description": "pipeline.pandas.0-main",
        "peekOfCode": "from_numpy = __import__('0-from_numpy').from_numpy\nnp.random.seed(0)\nA = np.random.randn(5, 8)\nprint(from_numpy(A))\nB = np.random.randn(9, 3)\nprint(from_numpy(B))",
        "detail": "pipeline.pandas.0-main",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "pipeline.pandas.0-main",
        "description": "pipeline.pandas.0-main",
        "peekOfCode": "A = np.random.randn(5, 8)\nprint(from_numpy(A))\nB = np.random.randn(9, 3)\nprint(from_numpy(B))",
        "detail": "pipeline.pandas.0-main",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "pipeline.pandas.0-main",
        "description": "pipeline.pandas.0-main",
        "peekOfCode": "B = np.random.randn(9, 3)\nprint(from_numpy(B))",
        "detail": "pipeline.pandas.0-main",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "pipeline.pandas.1-from_dictionary",
        "description": "pipeline.pandas.1-from_dictionary",
        "peekOfCode": "data = {\n    'First':  [0.0, 0.5, 1.0, 1.5],\n    'Second': [\"one\", \"two\", \"three\", \"four\"],\n}\ndf = pd.DataFrame(data, index=[\"A\", \"B\", \"C\", \"D\"])",
        "detail": "pipeline.pandas.1-from_dictionary",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.1-from_dictionary",
        "description": "pipeline.pandas.1-from_dictionary",
        "peekOfCode": "df = pd.DataFrame(data, index=[\"A\", \"B\", \"C\", \"D\"])",
        "detail": "pipeline.pandas.1-from_dictionary",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.1-main",
        "description": "pipeline.pandas.1-main",
        "peekOfCode": "df = __import__('1-from_dictionary').df\nprint(df)",
        "detail": "pipeline.pandas.1-main",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "pipeline.pandas.10-index",
        "description": "pipeline.pandas.10-index",
        "peekOfCode": "def index(df):\n    '''\n    A function that sets the Timestamp column of a DataFrame as its index.\n    '''\n    df = df.set_index('Timestamp')\n    return df",
        "detail": "pipeline.pandas.10-index",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.10-main",
        "description": "pipeline.pandas.10-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nindex = __import__('10-index').index\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = index(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.10-main",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "pipeline.pandas.10-main",
        "description": "pipeline.pandas.10-main",
        "peekOfCode": "index = __import__('10-index').index\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = index(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.10-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.10-main",
        "description": "pipeline.pandas.10-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = index(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.10-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.10-main",
        "description": "pipeline.pandas.10-main",
        "peekOfCode": "df = index(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.10-main",
        "documentation": {}
    },
    {
        "label": "concat",
        "kind": 2,
        "importPath": "pipeline.pandas.11-concat",
        "description": "pipeline.pandas.11-concat",
        "peekOfCode": "def concat(df1, df2):\n    \"\"\"A function that concatenates DataFrames\"\"\"\n    df1 = index(df1)\n    df2 = index(df2)\n    df2 = df2.loc[:1417411920]\n    combined = pd.concat([df2, df1], keys=['bitstamp', 'coinbase'])\n    return combined",
        "detail": "pipeline.pandas.11-concat",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "pipeline.pandas.11-concat",
        "description": "pipeline.pandas.11-concat",
        "peekOfCode": "index = __import__('10-index').index\ndef concat(df1, df2):\n    \"\"\"A function that concatenates DataFrames\"\"\"\n    df1 = index(df1)\n    df2 = index(df2)\n    df2 = df2.loc[:1417411920]\n    combined = pd.concat([df2, df1], keys=['bitstamp', 'coinbase'])\n    return combined",
        "detail": "pipeline.pandas.11-concat",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.11-main",
        "description": "pipeline.pandas.11-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nconcat = __import__('11-concat').concat\ndf1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = concat(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.11-main",
        "documentation": {}
    },
    {
        "label": "concat",
        "kind": 5,
        "importPath": "pipeline.pandas.11-main",
        "description": "pipeline.pandas.11-main",
        "peekOfCode": "concat = __import__('11-concat').concat\ndf1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = concat(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.11-main",
        "documentation": {}
    },
    {
        "label": "df1",
        "kind": 5,
        "importPath": "pipeline.pandas.11-main",
        "description": "pipeline.pandas.11-main",
        "peekOfCode": "df1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = concat(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.11-main",
        "documentation": {}
    },
    {
        "label": "df2",
        "kind": 5,
        "importPath": "pipeline.pandas.11-main",
        "description": "pipeline.pandas.11-main",
        "peekOfCode": "df2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = concat(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.11-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.11-main",
        "description": "pipeline.pandas.11-main",
        "peekOfCode": "df = concat(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.11-main",
        "documentation": {}
    },
    {
        "label": "hierarchy",
        "kind": 2,
        "importPath": "pipeline.pandas.12-hierarchy",
        "description": "pipeline.pandas.12-hierarchy",
        "peekOfCode": "def hierarchy(df1, df2):\n    \"\"\"A function that combines two tables by timestamp \"\"\"\n    df1 = index(df1)\n    df2 = index(df2)\n    df1_range = df1.loc[1417411980:1417417980]\n    df2_range = df2.loc[1417411980:1417417980]\n    combined = pd.concat([df2_range, df1_range], keys=['bitstamp', 'coinbase'])\n    combined = combined.swaplevel()\n    combined = combined.sort_index(level='Timestamp')\n    return combined",
        "detail": "pipeline.pandas.12-hierarchy",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "pipeline.pandas.12-hierarchy",
        "description": "pipeline.pandas.12-hierarchy",
        "peekOfCode": "index = __import__('10-index').index\ndef hierarchy(df1, df2):\n    \"\"\"A function that combines two tables by timestamp \"\"\"\n    df1 = index(df1)\n    df2 = index(df2)\n    df1_range = df1.loc[1417411980:1417417980]\n    df2_range = df2.loc[1417411980:1417417980]\n    combined = pd.concat([df2_range, df1_range], keys=['bitstamp', 'coinbase'])\n    combined = combined.swaplevel()\n    combined = combined.sort_index(level='Timestamp')",
        "detail": "pipeline.pandas.12-hierarchy",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.12-main",
        "description": "pipeline.pandas.12-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nhierarchy = __import__('12-hierarchy').hierarchy\ndf1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = hierarchy(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.12-main",
        "documentation": {}
    },
    {
        "label": "hierarchy",
        "kind": 5,
        "importPath": "pipeline.pandas.12-main",
        "description": "pipeline.pandas.12-main",
        "peekOfCode": "hierarchy = __import__('12-hierarchy').hierarchy\ndf1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = hierarchy(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.12-main",
        "documentation": {}
    },
    {
        "label": "df1",
        "kind": 5,
        "importPath": "pipeline.pandas.12-main",
        "description": "pipeline.pandas.12-main",
        "peekOfCode": "df1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = hierarchy(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.12-main",
        "documentation": {}
    },
    {
        "label": "df2",
        "kind": 5,
        "importPath": "pipeline.pandas.12-main",
        "description": "pipeline.pandas.12-main",
        "peekOfCode": "df2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\ndf = hierarchy(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.12-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.12-main",
        "description": "pipeline.pandas.12-main",
        "peekOfCode": "df = hierarchy(df1, df2)\nprint(df)",
        "detail": "pipeline.pandas.12-main",
        "documentation": {}
    },
    {
        "label": "analyze",
        "kind": 2,
        "importPath": "pipeline.pandas.13-analyze",
        "description": "pipeline.pandas.13-analyze",
        "peekOfCode": "def analyze(df):\n    \"\"\"A function that computes statistics for a DataFrame\"\"\"\n    df = df.drop(columns=['Timestamp']).describe()\n    return df",
        "detail": "pipeline.pandas.13-analyze",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.13-main",
        "description": "pipeline.pandas.13-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nanalyze = __import__('13-analyze').analyze\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nstats = analyze(df)\nprint(stats)",
        "detail": "pipeline.pandas.13-main",
        "documentation": {}
    },
    {
        "label": "analyze",
        "kind": 5,
        "importPath": "pipeline.pandas.13-main",
        "description": "pipeline.pandas.13-main",
        "peekOfCode": "analyze = __import__('13-analyze').analyze\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nstats = analyze(df)\nprint(stats)",
        "detail": "pipeline.pandas.13-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.13-main",
        "description": "pipeline.pandas.13-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nstats = analyze(df)\nprint(stats)",
        "detail": "pipeline.pandas.13-main",
        "documentation": {}
    },
    {
        "label": "stats",
        "kind": 5,
        "importPath": "pipeline.pandas.13-main",
        "description": "pipeline.pandas.13-main",
        "peekOfCode": "stats = analyze(df)\nprint(stats)",
        "detail": "pipeline.pandas.13-main",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "pipeline.pandas.14-visualize",
        "description": "pipeline.pandas.14-visualize",
        "peekOfCode": "def visualize():\n    \"\"\"\n    A function that visualizes and returns the transformed DataFrame\n    \"\"\"\n    df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\n    df = df.drop(columns=['Weighted_Price'])\n    df = df.rename(columns={'Timestamp': 'Date'})\n    df['Date'] = pd.to_datetime(df['Date'], unit='s')\n    df = df.set_index('Date')\n    df['Close'] = df['Close'].ffill()",
        "detail": "pipeline.pandas.14-visualize",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.14-visualize",
        "description": "pipeline.pandas.14-visualize",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\ndef visualize():\n    \"\"\"\n    A function that visualizes and returns the transformed DataFrame\n    \"\"\"\n    df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\n    df = df.drop(columns=['Weighted_Price'])\n    df = df.rename(columns={'Timestamp': 'Date'})\n    df['Date'] = pd.to_datetime(df['Date'], unit='s')\n    df = df.set_index('Date')",
        "detail": "pipeline.pandas.14-visualize",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 2,
        "importPath": "pipeline.pandas.2-from_file",
        "description": "pipeline.pandas.2-from_file",
        "peekOfCode": "def from_file(filename, delimiter):\n    \"\"\"A function that loads data from a file as a pandas DataFrame\"\"\"\n    return pd.read_csv(filename, delimiter=delimiter)",
        "detail": "pipeline.pandas.2-from_file",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.2-main",
        "description": "pipeline.pandas.2-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\ndf1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nprint(df1.head())\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\nprint(df2.tail())",
        "detail": "pipeline.pandas.2-main",
        "documentation": {}
    },
    {
        "label": "df1",
        "kind": 5,
        "importPath": "pipeline.pandas.2-main",
        "description": "pipeline.pandas.2-main",
        "peekOfCode": "df1 = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nprint(df1.head())\ndf2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\nprint(df2.tail())",
        "detail": "pipeline.pandas.2-main",
        "documentation": {}
    },
    {
        "label": "df2",
        "kind": 5,
        "importPath": "pipeline.pandas.2-main",
        "description": "pipeline.pandas.2-main",
        "peekOfCode": "df2 = from_file('bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', ',')\nprint(df2.tail())",
        "detail": "pipeline.pandas.2-main",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.3-main",
        "description": "pipeline.pandas.3-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nrename = __import__('3-rename').rename\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = rename(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.3-main",
        "documentation": {}
    },
    {
        "label": "rename",
        "kind": 5,
        "importPath": "pipeline.pandas.3-main",
        "description": "pipeline.pandas.3-main",
        "peekOfCode": "rename = __import__('3-rename').rename\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = rename(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.3-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.3-main",
        "description": "pipeline.pandas.3-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = rename(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.3-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.3-main",
        "description": "pipeline.pandas.3-main",
        "peekOfCode": "df = rename(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.3-main",
        "documentation": {}
    },
    {
        "label": "rename",
        "kind": 2,
        "importPath": "pipeline.pandas.3-rename",
        "description": "pipeline.pandas.3-rename",
        "peekOfCode": "def rename(df):\n    '''A function that renames 'Timestamp' to 'Datetime',\n    converts it to datetime format, and keeps only 'Datetime'\n    and 'Close' columns '''\n    df = df.rename(columns={'Timestamp': 'Datetime'})\n    df['Datetime'] = pd.to_datetime(df['Datetime'], unit='s')\n    df = df[['Datetime', 'Close']]\n    return df",
        "detail": "pipeline.pandas.3-rename",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 2,
        "importPath": "pipeline.pandas.4-array",
        "description": "pipeline.pandas.4-array",
        "peekOfCode": "def array(df):\n    '''\n    A function that select the last 10 rows of\n    'High' and 'Close' columns and return them as a numpy array\n    '''\n    last_10 = df[['High', 'Close']].tail(10)\n    return last_10.to_numpy()",
        "detail": "pipeline.pandas.4-array",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.4-main",
        "description": "pipeline.pandas.4-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\narray = __import__('4-array').array\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nA = array(df)\nprint(A)",
        "detail": "pipeline.pandas.4-main",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 5,
        "importPath": "pipeline.pandas.4-main",
        "description": "pipeline.pandas.4-main",
        "peekOfCode": "array = __import__('4-array').array\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nA = array(df)\nprint(A)",
        "detail": "pipeline.pandas.4-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.4-main",
        "description": "pipeline.pandas.4-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\nA = array(df)\nprint(A)",
        "detail": "pipeline.pandas.4-main",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "pipeline.pandas.4-main",
        "description": "pipeline.pandas.4-main",
        "peekOfCode": "A = array(df)\nprint(A)",
        "detail": "pipeline.pandas.4-main",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.5-main",
        "description": "pipeline.pandas.5-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nslice = __import__('5-slice').slice\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = slice(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.5-main",
        "documentation": {}
    },
    {
        "label": "slice",
        "kind": 5,
        "importPath": "pipeline.pandas.5-main",
        "description": "pipeline.pandas.5-main",
        "peekOfCode": "slice = __import__('5-slice').slice\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = slice(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.5-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.5-main",
        "description": "pipeline.pandas.5-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = slice(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.5-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.5-main",
        "description": "pipeline.pandas.5-main",
        "peekOfCode": "df = slice(df)\nprint(df.tail())",
        "detail": "pipeline.pandas.5-main",
        "documentation": {}
    },
    {
        "label": "slice",
        "kind": 2,
        "importPath": "pipeline.pandas.5-slice",
        "description": "pipeline.pandas.5-slice",
        "peekOfCode": "def slice(df):\n    \"\"\"A function that returns a sliced DataFrame\"\"\"\n    selected_columns = df[['High', 'Low', 'Close', 'Volume_(BTC)']]\n    sliced_df = selected_columns[::60]\n    return sliced_df",
        "detail": "pipeline.pandas.5-slice",
        "documentation": {}
    },
    {
        "label": "flip_switch",
        "kind": 2,
        "importPath": "pipeline.pandas.6-flip_switch",
        "description": "pipeline.pandas.6-flip_switch",
        "peekOfCode": "def flip_switch(df):\n    \"\"\"\n    A function that .\n    \"\"\"\n    df_reversed = df.sort_index(ascending=False)\n    df_transposed = df_reversed.T\n    return df_transposed",
        "detail": "pipeline.pandas.6-flip_switch",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.6-main",
        "description": "pipeline.pandas.6-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nflip_switch = __import__('6-flip_switch').flip_switch\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = flip_switch(df)\nprint(df.tail(8))",
        "detail": "pipeline.pandas.6-main",
        "documentation": {}
    },
    {
        "label": "flip_switch",
        "kind": 5,
        "importPath": "pipeline.pandas.6-main",
        "description": "pipeline.pandas.6-main",
        "peekOfCode": "flip_switch = __import__('6-flip_switch').flip_switch\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = flip_switch(df)\nprint(df.tail(8))",
        "detail": "pipeline.pandas.6-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.6-main",
        "description": "pipeline.pandas.6-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = flip_switch(df)\nprint(df.tail(8))",
        "detail": "pipeline.pandas.6-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.6-main",
        "description": "pipeline.pandas.6-main",
        "peekOfCode": "df = flip_switch(df)\nprint(df.tail(8))",
        "detail": "pipeline.pandas.6-main",
        "documentation": {}
    },
    {
        "label": "high",
        "kind": 2,
        "importPath": "pipeline.pandas.7-high",
        "description": "pipeline.pandas.7-high",
        "peekOfCode": "def high(df):\n    '''\n    A function that sorts a DataFrame by the High column in descending order\n    '''\n    sorted_df = df.sort_values(by='High', ascending=False)\n    return sorted_df",
        "detail": "pipeline.pandas.7-high",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.7-main",
        "description": "pipeline.pandas.7-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nhigh = __import__('7-high').high\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = high(df)\nprint(df.head())",
        "detail": "pipeline.pandas.7-main",
        "documentation": {}
    },
    {
        "label": "high",
        "kind": 5,
        "importPath": "pipeline.pandas.7-main",
        "description": "pipeline.pandas.7-main",
        "peekOfCode": "high = __import__('7-high').high\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = high(df)\nprint(df.head())",
        "detail": "pipeline.pandas.7-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.7-main",
        "description": "pipeline.pandas.7-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = high(df)\nprint(df.head())",
        "detail": "pipeline.pandas.7-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.7-main",
        "description": "pipeline.pandas.7-main",
        "peekOfCode": "df = high(df)\nprint(df.head())",
        "detail": "pipeline.pandas.7-main",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.8-main",
        "description": "pipeline.pandas.8-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nprune = __import__('8-prune').prune\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = prune(df)\nprint(df.head())",
        "detail": "pipeline.pandas.8-main",
        "documentation": {}
    },
    {
        "label": "prune",
        "kind": 5,
        "importPath": "pipeline.pandas.8-main",
        "description": "pipeline.pandas.8-main",
        "peekOfCode": "prune = __import__('8-prune').prune\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = prune(df)\nprint(df.head())",
        "detail": "pipeline.pandas.8-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.8-main",
        "description": "pipeline.pandas.8-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = prune(df)\nprint(df.head())",
        "detail": "pipeline.pandas.8-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.8-main",
        "description": "pipeline.pandas.8-main",
        "peekOfCode": "df = prune(df)\nprint(df.head())",
        "detail": "pipeline.pandas.8-main",
        "documentation": {}
    },
    {
        "label": "prune",
        "kind": 2,
        "importPath": "pipeline.pandas.8-prune",
        "description": "pipeline.pandas.8-prune",
        "peekOfCode": "def prune(df):\n    '''\n    A function that removes any entries where Close has NaN values\n    and returns DataFrame\n    '''\n    cleaned_df = df[df['Close'].notna()]\n    return cleaned_df",
        "detail": "pipeline.pandas.8-prune",
        "documentation": {}
    },
    {
        "label": "fill",
        "kind": 2,
        "importPath": "pipeline.pandas.9-fill",
        "description": "pipeline.pandas.9-fill",
        "peekOfCode": "def fill(df):\n    '''\n    A function that fill NaN values in a pandas data frame.\n    '''\n    df = df.drop(columns='Weighted_Price')\n    df['Close'] = df['Close'].ffill(axis=0)\n    df['High'] = df['High'].fillna(df['Close'])\n    df['Low'] = df['Low'].fillna(df['Close'])\n    df['Open'] = df['Open'].fillna(df['Close'])\n    df['Volume_(BTC)'] = df['Volume_(BTC)'].fillna(0)",
        "detail": "pipeline.pandas.9-fill",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 5,
        "importPath": "pipeline.pandas.9-main",
        "description": "pipeline.pandas.9-main",
        "peekOfCode": "from_file = __import__('2-from_file').from_file\nfill = __import__('9-fill').fill\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = fill(df)\nprint(df.head())\nprint(df.tail())",
        "detail": "pipeline.pandas.9-main",
        "documentation": {}
    },
    {
        "label": "fill",
        "kind": 5,
        "importPath": "pipeline.pandas.9-main",
        "description": "pipeline.pandas.9-main",
        "peekOfCode": "fill = __import__('9-fill').fill\ndf = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = fill(df)\nprint(df.head())\nprint(df.tail())",
        "detail": "pipeline.pandas.9-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.9-main",
        "description": "pipeline.pandas.9-main",
        "peekOfCode": "df = from_file('coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', ',')\ndf = fill(df)\nprint(df.head())\nprint(df.tail())",
        "detail": "pipeline.pandas.9-main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "pipeline.pandas.9-main",
        "description": "pipeline.pandas.9-main",
        "peekOfCode": "df = fill(df)\nprint(df.head())\nprint(df.tail())",
        "detail": "pipeline.pandas.9-main",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.0-neuron",
        "description": "supervised_learning.classification.0-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"\n    A class that defines a neuron for binary classification.\n    \"\"\"\n    def __init__(self, nx):\n        \"\"\"\n        A function that initializes weights, bias, and output for the neuron.\n        \"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")",
        "detail": "supervised_learning.classification.0-neuron",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.1-neuron",
        "description": "supervised_learning.classification.1-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.1-neuron",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.10-neural_network",
        "description": "supervised_learning.classification.10-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.10-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.11-neural_network",
        "description": "supervised_learning.classification.11-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.11-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.12-neural_network",
        "description": "supervised_learning.classification.12-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.12-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.13-neural_network",
        "description": "supervised_learning.classification.13-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.13-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.14-neural_network",
        "description": "supervised_learning.classification.14-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.14-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.15-neural_network",
        "description": "supervised_learning.classification.15-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.15-neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.16-deep_neural_network",
        "description": "supervised_learning.classification.16-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.16-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.17-deep_neural_network",
        "description": "supervised_learning.classification.17-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.17-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.18-deep_neural_network",
        "description": "supervised_learning.classification.18-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.18-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.19-deep_neural_network",
        "description": "supervised_learning.classification.19-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.19-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.2-neuron",
        "description": "supervised_learning.classification.2-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.2-neuron",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.20-deep_neural_network",
        "description": "supervised_learning.classification.20-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.20-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.21-deep_neural_network",
        "description": "supervised_learning.classification.21-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.21-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.22-deep_neural_network",
        "description": "supervised_learning.classification.22-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.22-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.23-deep_neural_network",
        "description": "supervised_learning.classification.23-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.23-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "one_hot_encode",
        "kind": 2,
        "importPath": "supervised_learning.classification.24-one_hot_encode",
        "description": "supervised_learning.classification.24-one_hot_encode",
        "peekOfCode": "def one_hot_encode(Y, classes):\n    \"\"\"\n    A function that converts a numeric label vector into a one-hot matrix\n    \"\"\"\n    if type(Y) is not np.ndarray or len(Y.shape) != 1:\n        return None\n    if type(classes) is not int or classes <= 0:\n        return None\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))",
        "detail": "supervised_learning.classification.24-one_hot_encode",
        "documentation": {}
    },
    {
        "label": "one_hot_decode",
        "kind": 2,
        "importPath": "supervised_learning.classification.25-one_hot_decode",
        "description": "supervised_learning.classification.25-one_hot_decode",
        "peekOfCode": "def one_hot_decode(one_hot):\n    \"\"\"\n    A function that returns a converted one-hot matrix into a vector of labels\n    \"\"\"\n    if type(one_hot) is not np.ndarray or len(one_hot.shape) != 2:\n        return None\n    return np.argmax(one_hot, axis=0)",
        "detail": "supervised_learning.classification.25-one_hot_decode",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.26-deep_neural_network",
        "description": "supervised_learning.classification.26-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.26-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.27-deep_neural_network",
        "description": "supervised_learning.classification.27-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.27-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "DeepNeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.28-deep_neural_network",
        "description": "supervised_learning.classification.28-deep_neural_network",
        "peekOfCode": "class DeepNeuralNetwork:\n    \"\"\"\n    A class that implements a deep neural network for binary classification.\n    \"\"\"\n    def __init__(self, nx, layers, activation='sig'):\n        \"\"\"\n        A constructor that takes number of input as nx and\n        layers is a list representing the number of nodes\n        in each layer of the network\n        \"\"\"",
        "detail": "supervised_learning.classification.28-deep_neural_network",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.3-neuron",
        "description": "supervised_learning.classification.3-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.3-neuron",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.4-neuron",
        "description": "supervised_learning.classification.4-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.4-neuron",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.5-neuron",
        "description": "supervised_learning.classification.5-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.5-neuron",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.6-neuron",
        "description": "supervised_learning.classification.6-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.6-neuron",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "kind": 6,
        "importPath": "supervised_learning.classification.7-neuron",
        "description": "supervised_learning.classification.7-neuron",
        "peekOfCode": "class Neuron:\n    \"\"\"A class that defines a neuron for binary classification.\"\"\"\n    def __init__(self, nx):\n        \"\"\"A function that initializes weights, bias, and output.\"\"\"\n        if type(nx) is not int:\n            raise TypeError(\"nx must be an integer\")\n        if nx < 1:\n            raise ValueError(\"nx must be a positive integer\")\n        self.__W = np.random.randn(1, nx)\n        self.__b = 0",
        "detail": "supervised_learning.classification.7-neuron",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.8-neural_network",
        "description": "supervised_learning.classification.8-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.8-neural_network",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "supervised_learning.classification.9-neural_network",
        "description": "supervised_learning.classification.9-neural_network",
        "peekOfCode": "class NeuralNetwork:\n    \"\"\"\n    A class that represents a neural network used for binary classification.\n    \"\"\"\n    def __init__(self, nx, nodes):\n        \"\"\"\n        A constructor function that initializes a NeuralNetwork object\n        using `nx` as the number of input features and `nodes` as the\n        number of neurons in the hidden layer.\n        \"\"\"",
        "detail": "supervised_learning.classification.9-neural_network",
        "documentation": {}
    },
    {
        "label": "create_confusion_matrix",
        "kind": 2,
        "importPath": "supervised_learning.error_analysis.0-create_confusion",
        "description": "supervised_learning.error_analysis.0-create_confusion",
        "peekOfCode": "def create_confusion_matrix(labels, logits):\n    \"\"\"\n        A function that creates a confusion matrix\n        :param labels: ndarray, shape(m,classes), correct labels\n        :param logits: ndarray, shape(m,classes), predicted labels\n        :return: ndarray, shape(classes,classes),\n                row indices = correct labels,\n                columns indices = predicted labels\n    \"\"\"\n    # number of example",
        "detail": "supervised_learning.error_analysis.0-create_confusion",
        "documentation": {}
    },
    {
        "label": "create_confusion_matrix",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.0-main",
        "description": "supervised_learning.error_analysis.0-main",
        "peekOfCode": "create_confusion_matrix = \\\n    __import__('0-create_confusion').create_confusion_matrix\nif __name__ == '__main__':\n    lib = np.load('labels_logits.npz')\n    labels = lib['labels']\n    logits = lib['logits']\n    np.set_printoptions(suppress=True)\n    confusion = create_confusion_matrix(labels, logits)\n    print(confusion)\n    np.savez_compressed('confusion.npz', confusion=confusion)",
        "detail": "supervised_learning.error_analysis.0-main",
        "documentation": {}
    },
    {
        "label": "sensitivity",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.1-main",
        "description": "supervised_learning.error_analysis.1-main",
        "peekOfCode": "sensitivity = __import__('1-sensitivity').sensitivity\nif __name__ == '__main__':\n    confusion = np.load('confusion.npz')['confusion']\n    np.set_printoptions(suppress=True)\n    print(sensitivity(confusion))",
        "detail": "supervised_learning.error_analysis.1-main",
        "documentation": {}
    },
    {
        "label": "sensitivity",
        "kind": 2,
        "importPath": "supervised_learning.error_analysis.1-sensitivity",
        "description": "supervised_learning.error_analysis.1-sensitivity",
        "peekOfCode": "def sensitivity(confusion):\n    \"\"\"\n        A function that calculates the sensitivity for each class\n        in a confusion matrix\n        :param confusion: ndarray, shape(classes,classes), matrix confusion\n        :return: ndarray, shape(classes,) containing sensitivity of each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]\n    # initialize sensitivity",
        "detail": "supervised_learning.error_analysis.1-sensitivity",
        "documentation": {}
    },
    {
        "label": "precision",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.2-main",
        "description": "supervised_learning.error_analysis.2-main",
        "peekOfCode": "precision = __import__('2-precision').precision\nif __name__ == '__main__':\n    confusion = np.load('confusion.npz')['confusion']\n    np.set_printoptions(suppress=True)\n    print(precision(confusion))",
        "detail": "supervised_learning.error_analysis.2-main",
        "documentation": {}
    },
    {
        "label": "precision",
        "kind": 2,
        "importPath": "supervised_learning.error_analysis.2-precision",
        "description": "supervised_learning.error_analysis.2-precision",
        "peekOfCode": "def precision(confusion):\n    \"\"\"\n        A function that calculates the precision for each class\n        in a confusion matrix\n        :param confusion: ndarray, shape(classes,classes), confusion matrix\n        :return: ndarray, shape(classes,), precision for each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]\n    # initialize sensitivity",
        "detail": "supervised_learning.error_analysis.2-precision",
        "documentation": {}
    },
    {
        "label": "specificity",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.3-main",
        "description": "supervised_learning.error_analysis.3-main",
        "peekOfCode": "specificity = __import__('3-specificity').specificity\nif __name__ == '__main__':\n    confusion = np.load('confusion.npz')['confusion']\n    np.set_printoptions(suppress=True)\n    print(specificity(confusion))",
        "detail": "supervised_learning.error_analysis.3-main",
        "documentation": {}
    },
    {
        "label": "specificity",
        "kind": 2,
        "importPath": "supervised_learning.error_analysis.3-specificity",
        "description": "supervised_learning.error_analysis.3-specificity",
        "peekOfCode": "def specificity(confusion):\n    \"\"\"\n        A function that calculates specificity of each class\n        in a confusion matrix\n        :param confusion: ndarray, shape(classes,classes) confusion matrix\n        :return: ndarray, shape(classes,), specificity of each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]\n    # initialize specificity",
        "detail": "supervised_learning.error_analysis.3-specificity",
        "documentation": {}
    },
    {
        "label": "f1_score",
        "kind": 2,
        "importPath": "supervised_learning.error_analysis.4-f1_score",
        "description": "supervised_learning.error_analysis.4-f1_score",
        "peekOfCode": "def f1_score(confusion):\n    \"\"\"\n        A function that calculates F1 score of a confusion matrix\n        :param confusion: ndarray, shape(classes, classes)\n        :return: ndarray, shape(classes,) F1 score of each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]\n    # initialize f1 score matrix\n    f_one = np.zeros((classes,))",
        "detail": "supervised_learning.error_analysis.4-f1_score",
        "documentation": {}
    },
    {
        "label": "sensitivity",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.4-f1_score",
        "description": "supervised_learning.error_analysis.4-f1_score",
        "peekOfCode": "sensitivity = __import__('1-sensitivity').sensitivity\nprecision = __import__('2-precision').precision\ndef f1_score(confusion):\n    \"\"\"\n        A function that calculates F1 score of a confusion matrix\n        :param confusion: ndarray, shape(classes, classes)\n        :return: ndarray, shape(classes,) F1 score of each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]",
        "detail": "supervised_learning.error_analysis.4-f1_score",
        "documentation": {}
    },
    {
        "label": "precision",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.4-f1_score",
        "description": "supervised_learning.error_analysis.4-f1_score",
        "peekOfCode": "precision = __import__('2-precision').precision\ndef f1_score(confusion):\n    \"\"\"\n        A function that calculates F1 score of a confusion matrix\n        :param confusion: ndarray, shape(classes, classes)\n        :return: ndarray, shape(classes,) F1 score of each class\n    \"\"\"\n    # number of classes\n    classes = confusion.shape[0]\n    # initialize f1 score matrix",
        "detail": "supervised_learning.error_analysis.4-f1_score",
        "documentation": {}
    },
    {
        "label": "f1_score",
        "kind": 5,
        "importPath": "supervised_learning.error_analysis.4-main",
        "description": "supervised_learning.error_analysis.4-main",
        "peekOfCode": "f1_score = __import__('4-f1_score').f1_score\nif __name__ == '__main__':\n    confusion = np.load('confusion.npz')['confusion']\n    np.set_printoptions(suppress=True)\n    print(f1_score(confusion))",
        "detail": "supervised_learning.error_analysis.4-main",
        "documentation": {}
    },
    {
        "label": "build_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.0-sequential",
        "description": "supervised_learning.keras.0-sequential",
        "peekOfCode": "def build_model(nx, layers, activations, lambtha, keep_prob):\n    \"\"\"\n    A function that constructs a neural network with the Keras library,\n    incorporating L2 regularization and dropout\n    to enhance generalization and prevent overfitting.\n    \"\"\"\n    model = K.Sequential()\n    for i in range(len(layers)):\n        if i == 0:\n            model.add(K.layers.Dense(layers[i],",
        "detail": "supervised_learning.keras.0-sequential",
        "documentation": {}
    },
    {
        "label": "build_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.1-input",
        "description": "supervised_learning.keras.1-input",
        "peekOfCode": "def build_model(nx, layers, activations, lambtha, keep_prob):\n    \"\"\"\n    A function that constructs a neural network using the Keras library.\n    The model is built with configurable layers, activation functions,\n    L2 regularization, and dropout for improved generalization.\n    \"\"\"\n    inputs = K.Input(shape=(nx,))\n    x = inputs\n    for i in range(len(layers)):\n        x = K.layers.Dense(layers[i],",
        "detail": "supervised_learning.keras.1-input",
        "documentation": {}
    },
    {
        "label": "save_weights",
        "kind": 2,
        "importPath": "supervised_learning.keras.10-weights",
        "description": "supervised_learning.keras.10-weights",
        "peekOfCode": "def save_weights(network, filename, save_format='h5'):\n    \"\"\"\n        A function that saves a model's weights\n    \"\"\"\n    network.save_weights(filepath=filename,\n                         save_format=save_format)\ndef load_weights(network, filename):\n    \"\"\"\n        A function that loads a model's weights\n    \"\"\"",
        "detail": "supervised_learning.keras.10-weights",
        "documentation": {}
    },
    {
        "label": "load_weights",
        "kind": 2,
        "importPath": "supervised_learning.keras.10-weights",
        "description": "supervised_learning.keras.10-weights",
        "peekOfCode": "def load_weights(network, filename):\n    \"\"\"\n        A function that loads a model's weights\n    \"\"\"\n    network.load_weights(filepath=filename)",
        "detail": "supervised_learning.keras.10-weights",
        "documentation": {}
    },
    {
        "label": "save_config",
        "kind": 2,
        "importPath": "supervised_learning.keras.11-config",
        "description": "supervised_learning.keras.11-config",
        "peekOfCode": "def save_config(network, filename):\n    \"\"\"\n        A function that saves a model's configuration in JSON format\n    \"\"\"\n    network_config = network.to_json()\n    with open(filename, \"w\") as f:\n        f.write(network_config)\ndef load_config(filename):\n    \"\"\"\n        A function that loads a model with a specific configuration",
        "detail": "supervised_learning.keras.11-config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "supervised_learning.keras.11-config",
        "description": "supervised_learning.keras.11-config",
        "peekOfCode": "def load_config(filename):\n    \"\"\"\n        A function that loads a model with a specific configuration\n    \"\"\"\n    with open(filename, \"r\") as f:\n        load_network_config = f.read()\n    return K.models.model_from_json(load_network_config)",
        "detail": "supervised_learning.keras.11-config",
        "documentation": {}
    },
    {
        "label": "test_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.12-test",
        "description": "supervised_learning.keras.12-test",
        "peekOfCode": "def test_model(network, data, labels, verbose=True):\n    \"\"\"\n        A function that tests a neural network\n    \"\"\"\n    return network.evaluate(x=data,\n                            y=labels,\n                            verbose=verbose)",
        "detail": "supervised_learning.keras.12-test",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "supervised_learning.keras.13-predict",
        "description": "supervised_learning.keras.13-predict",
        "peekOfCode": "def predict(network, data, verbose=False):\n    \"\"\"\n        A function that makes prediction using a neural network\n    \"\"\"\n    return network.predict(x=data,\n                           verbose=verbose)",
        "detail": "supervised_learning.keras.13-predict",
        "documentation": {}
    },
    {
        "label": "optimize_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.2-optimize",
        "description": "supervised_learning.keras.2-optimize",
        "peekOfCode": "def optimize_model(network, alpha, beta1, beta2):\n    \"\"\"\n    A function that configures the Adam optimizer for a Keras model\n    using categorical cross-entropy loss and accuracy metrics,\n    with adjustable learning rate and beta parameters.\n    \"\"\"\n    Adam_optimizer = K.optimizers.Adam(learning_rate=alpha,\n                                       beta_1=beta1,\n                                       beta_2=beta2)\n    network.compile(optimizer=Adam_optimizer,",
        "detail": "supervised_learning.keras.2-optimize",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.keras.3-one_hot",
        "description": "supervised_learning.keras.3-one_hot",
        "peekOfCode": "def one_hot(labels, classes=None):\n    \"\"\"\n    A function that converts a label vector into a one-hot encoded matrix.\n    Returns a matrix of shape (labels, classes).\n    \"\"\"\n    return K.utils.to_categorical(labels, classes)",
        "detail": "supervised_learning.keras.3-one_hot",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.4-train",
        "description": "supervised_learning.keras.4-train",
        "peekOfCode": "def train_model(network, data, labels, batch_size,\n                epochs, verbose=True, shuffle=False):\n    \"\"\"\n    A function that trains a model using mini-batch gradient descent.\n    Returns the training history of the model.\n    \"\"\"\n    history = network.fit(x=data,\n                          y=labels,\n                          epochs=epochs,\n                          batch_size=batch_size,",
        "detail": "supervised_learning.keras.4-train",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.5-train",
        "description": "supervised_learning.keras.5-train",
        "peekOfCode": "def train_model(network, data, labels, batch_size,\n                epochs, validation_data=None, verbose=True, shuffle=False):\n    \"\"\"\n    A function that trains a model using mini-batch gradient descent\n    with optional validation data. Returns the training history.\n    \"\"\"\n    history = network.fit(x=data,\n                          y=labels,\n                          epochs=epochs,\n                          batch_size=batch_size,",
        "detail": "supervised_learning.keras.5-train",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.6-train",
        "description": "supervised_learning.keras.6-train",
        "peekOfCode": "def train_model(network, data, labels, batch_size,\n                epochs, validation_data=None, early_stopping=False,\n                patience=0, verbose=True, shuffle=False):\n    \"\"\"\n    A function that trains a model using mini-batch gradient descent,\n    supporting early stopping and optional validation data.\n    \"\"\"\n    callback = []\n    if early_stopping is True and validation_data is not None:\n        callback = K.callbacks.EarlyStopping(monitor='val_loss',",
        "detail": "supervised_learning.keras.6-train",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.7-train",
        "description": "supervised_learning.keras.7-train",
        "peekOfCode": "def train_model(network, data, labels, batch_size,\n                epochs, validation_data=None, early_stopping=False,\n                patience=0, learning_rate_decay=False, alpha=0.1,\n                decay_rate=1, verbose=True, shuffle=False):\n    \"\"\"\n    A function that trains a model using mini-batch gradient descent\n    with support for early stopping, learning rate decay,\n    and optional validation data.\n    \"\"\"\n    callback = []",
        "detail": "supervised_learning.keras.7-train",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.8-train",
        "description": "supervised_learning.keras.8-train",
        "peekOfCode": "def train_model(network, data, labels, batch_size,\n                epochs, validation_data=None, early_stopping=False,\n                patience=0, learning_rate_decay=False, alpha=0.1,\n                decay_rate=1, save_best=False, filepath=None,\n                verbose=True, shuffle=False):\n    \"\"\"\n    A function that trains a model using mini-batch\n    gradient descent with optional early stopping,\n    learning rate decay, and model checkpointing for the best weights.\n    \"\"\"",
        "detail": "supervised_learning.keras.8-train",
        "documentation": {}
    },
    {
        "label": "save_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.9-model",
        "description": "supervised_learning.keras.9-model",
        "peekOfCode": "def save_model(network, filename):\n    \"\"\"\n    A function that saves a complete Keras model to the specified file path.\n    \"\"\"\n    network.save(filename)\ndef load_model(filename):\n    \"\"\"\n    A function that loads a complete Keras model from the specified file path.\n    Returns the loaded model.\n    \"\"\"",
        "detail": "supervised_learning.keras.9-model",
        "documentation": {}
    },
    {
        "label": "load_model",
        "kind": 2,
        "importPath": "supervised_learning.keras.9-model",
        "description": "supervised_learning.keras.9-model",
        "peekOfCode": "def load_model(filename):\n    \"\"\"\n    A function that loads a complete Keras model from the specified file path.\n    Returns the loaded model.\n    \"\"\"\n    return K.models.load_model(filename)",
        "detail": "supervised_learning.keras.9-model",
        "documentation": {}
    },
    {
        "label": "normalization_constants",
        "kind": 2,
        "importPath": "supervised_learning.optimization.0-norm_constants",
        "description": "supervised_learning.optimization.0-norm_constants",
        "peekOfCode": "def normalization_constants(X):\n    \"\"\"\n        A function that calculates the normalization constants\n    \"\"\"\n    return np.mean(X, axis=0), np.std(X, axis=0)",
        "detail": "supervised_learning.optimization.0-norm_constants",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "supervised_learning.optimization.1-normalize",
        "description": "supervised_learning.optimization.1-normalize",
        "peekOfCode": "def normalize(X, m, s):\n    \"\"\"\n        A function that calculates the normalization of a matrix\n    \"\"\"\n    # formula of normalisation Z = (X - mean) / std\n    Z = (X - m) / s\n    return Z",
        "detail": "supervised_learning.optimization.1-normalize",
        "documentation": {}
    },
    {
        "label": "create_Adam_op",
        "kind": 2,
        "importPath": "supervised_learning.optimization.10-Adam",
        "description": "supervised_learning.optimization.10-Adam",
        "peekOfCode": "def create_Adam_op(alpha, beta1, beta2, epsilon):\n    \"\"\"\n    A function that sets up the Adam\n    optimization algorithm in TensorFlow.\n    Args:\n        alpha (float): The learning rate.\n        beta1 (float): The weight used for the first moment.\n        beta2 (float): The weight used for the second moment.\n        epsilon (float): A small number to avoid division by zero.\n    Returns:",
        "detail": "supervised_learning.optimization.10-Adam",
        "documentation": {}
    },
    {
        "label": "learning_rate_decay",
        "kind": 2,
        "importPath": "supervised_learning.optimization.11-learning_rate_decay",
        "description": "supervised_learning.optimization.11-learning_rate_decay",
        "peekOfCode": "def learning_rate_decay(alpha, decay_rate, global_step, decay_step):\n    \"\"\"\n        A function that updates the learning rate using\n        inverse time decay in numpy\n    \"\"\"\n    # calculate factor that increases over time\n    factor = (1 + decay_rate * (global_step//decay_step))\n    # scale original learning rate by inverse of the factor\n    alpha = alpha / factor\n    return alpha",
        "detail": "supervised_learning.optimization.11-learning_rate_decay",
        "documentation": {}
    },
    {
        "label": "learning_rate_decay",
        "kind": 2,
        "importPath": "supervised_learning.optimization.12-learning_rate_decay",
        "description": "supervised_learning.optimization.12-learning_rate_decay",
        "peekOfCode": "def learning_rate_decay(alpha, decay_rate, decay_step):\n    \"\"\"\n    A function that creates a learning rate decay operation\n    in TensorFlow using inverse time decay.\n    Args:\n        alpha (float): The original learning rate.\n        decay_rate (float): The weight\n            used to determine the rate at which alpha will decay.\n        decay_step (int): The number of passes of\n            gradient descent that should occur before alpha is decayed further.",
        "detail": "supervised_learning.optimization.12-learning_rate_decay",
        "documentation": {}
    },
    {
        "label": "batch_norm",
        "kind": 2,
        "importPath": "supervised_learning.optimization.13-batch_norm",
        "description": "supervised_learning.optimization.13-batch_norm",
        "peekOfCode": "def batch_norm(Z, gamma, beta, epsilon):\n    \"\"\"\n        A function that normalizes an unactivated output of a NN\n        using batch normalization\n    \"\"\"\n    # compute mean and variance\n    mean = np.mean(Z, axis=0)\n    variance = np.var(Z, axis=0)\n    std_dev = np.sqrt(variance + epsilon)\n    # normalize : - mean / root square variance",
        "detail": "supervised_learning.optimization.13-batch_norm",
        "documentation": {}
    },
    {
        "label": "create_batch_norm_layer",
        "kind": 2,
        "importPath": "supervised_learning.optimization.14-batch_norm",
        "description": "supervised_learning.optimization.14-batch_norm",
        "peekOfCode": "def create_batch_norm_layer(prev, n, activation):\n    \"\"\"\n    A function that creates a batch normalization layer\n    for a neural network in TensorFlow.\n    Args:\n        prev (tensor): The activated output of the previous layer.\n        n (int): The number of nodes in the layer to be created.\n        activation (function): The activation function\n            that should be used on the output of the layer.\n    Returns:",
        "detail": "supervised_learning.optimization.14-batch_norm",
        "documentation": {}
    },
    {
        "label": "shuffle_data",
        "kind": 2,
        "importPath": "supervised_learning.optimization.2-shuffle_data",
        "description": "supervised_learning.optimization.2-shuffle_data",
        "peekOfCode": "def shuffle_data(X, Y):\n    \"\"\"\n        A function that shuffles the data points in two matrices the same way\n    \"\"\"\n    m = X.shape[0]\n    permutted_index = np.random.permutation(m)\n    X_shuffled = X[permutted_index]\n    Y_shuffled = Y[permutted_index]\n    return X_shuffled, Y_shuffled",
        "detail": "supervised_learning.optimization.2-shuffle_data",
        "documentation": {}
    },
    {
        "label": "create_mini_batches",
        "kind": 2,
        "importPath": "supervised_learning.optimization.3-mini_batch",
        "description": "supervised_learning.optimization.3-mini_batch",
        "peekOfCode": "def create_mini_batches(X, Y, batch_size):\n    \"\"\"\n    A function that creates mini-batches to be used for training\n    a neural network using mini-batch gradient descent.\n    Args:\n        X (numpy.ndarray): Input data of shape (m, nx).\n        Y (numpy.ndarray): Labels of shape (m, ny).\n        batch_size (int): Number of data points in a batch.\n    Returns:\n        list: List of mini-batches containing tuples (X_batch, Y_batch).",
        "detail": "supervised_learning.optimization.3-mini_batch",
        "documentation": {}
    },
    {
        "label": "shuffle_data",
        "kind": 5,
        "importPath": "supervised_learning.optimization.3-mini_batch",
        "description": "supervised_learning.optimization.3-mini_batch",
        "peekOfCode": "shuffle_data = __import__('2-shuffle_data').shuffle_data\ndef create_mini_batches(X, Y, batch_size):\n    \"\"\"\n    A function that creates mini-batches to be used for training\n    a neural network using mini-batch gradient descent.\n    Args:\n        X (numpy.ndarray): Input data of shape (m, nx).\n        Y (numpy.ndarray): Labels of shape (m, ny).\n        batch_size (int): Number of data points in a batch.\n    Returns:",
        "detail": "supervised_learning.optimization.3-mini_batch",
        "documentation": {}
    },
    {
        "label": "moving_average",
        "kind": 2,
        "importPath": "supervised_learning.optimization.4-moving_average",
        "description": "supervised_learning.optimization.4-moving_average",
        "peekOfCode": "def moving_average(data, beta):\n    \"\"\"\n        A function that calculates the weighted moving average of\n        a data set\n        Formul:\n        MA = (val1 + val2 +val3 + ... + valN) / N\n        :param data: list of data to calculate moving average\n        :param beta: weight used for moving average\n        :return: list containing the moving averages of data\n    \"\"\"",
        "detail": "supervised_learning.optimization.4-moving_average",
        "documentation": {}
    },
    {
        "label": "update_variables_momentum",
        "kind": 2,
        "importPath": "supervised_learning.optimization.5-momentum",
        "description": "supervised_learning.optimization.5-momentum",
        "peekOfCode": "def update_variables_momentum(alpha, beta1, var, grad, v):\n    \"\"\"\n        A function that updates a variable using the gradient descent\n        with momentum optimization algorithm\n        :param alpha: learning rate\n        :param beta1: momentum weight\n        :param var: ndarray, variable to be updated\n        :param grad: ndarray, gradient of var\n        :param v: previous first moment of var\n        :return: updated variable and the new moment",
        "detail": "supervised_learning.optimization.5-momentum",
        "documentation": {}
    },
    {
        "label": "create_momentum_op",
        "kind": 2,
        "importPath": "supervised_learning.optimization.6-momentum",
        "description": "supervised_learning.optimization.6-momentum",
        "peekOfCode": "def create_momentum_op(alpha, beta1):\n    \"\"\"\n    A function that sets up gradient descent with momentum\n    Args:\n        alpha (float): The learning rate.\n        beta1 (float): The momentum weight.\n    Returns:\n        optimizer: Optimizer object for gradient descent with momentum.\n    \"\"\"\n    optimizer = tf.keras.optimizers.SGD(",
        "detail": "supervised_learning.optimization.6-momentum",
        "documentation": {}
    },
    {
        "label": "update_variables_RMSProp",
        "kind": 2,
        "importPath": "supervised_learning.optimization.7-RMSProp",
        "description": "supervised_learning.optimization.7-RMSProp",
        "peekOfCode": "def update_variables_RMSProp(alpha, beta2, epsilon, var, grad, s):\n    \"\"\"\n        A function that updates a variable\n        using the RMSProp optimization algorithm\n        :param alpha: learning rate\n        :param beta2: RMSProp weight\n        :param epsilon: small number to avoid division by zero\n        :param var: ndarray, variable to be updated\n        :param grad: ndarray, gradient of var\n        :param s: previous second moment of var",
        "detail": "supervised_learning.optimization.7-RMSProp",
        "documentation": {}
    },
    {
        "label": "create_RMSProp_op",
        "kind": 2,
        "importPath": "supervised_learning.optimization.8-RMSProp",
        "description": "supervised_learning.optimization.8-RMSProp",
        "peekOfCode": "def create_RMSProp_op(alpha, beta2, epsilon):\n    \"\"\"\n    A function that sets up the RMSProp optimization algorithm in TensorFlow\n    Args:\n        alpha (float): The learning rate.\n        beta2 (float): The RMSProp weight (Discounting factor).\n        epsilon (float): A small number to avoid division by zero.\n    Returns:\n        optimizer: Optimizer object for RMSProp.\n    \"\"\"",
        "detail": "supervised_learning.optimization.8-RMSProp",
        "documentation": {}
    },
    {
        "label": "update_variables_Adam",
        "kind": 2,
        "importPath": "supervised_learning.optimization.9-Adam",
        "description": "supervised_learning.optimization.9-Adam",
        "peekOfCode": "def update_variables_Adam(alpha, beta1, beta2, epsilon, var, grad, v, s, t):\n    \"\"\"\n        A function that updates variable in place using\n        Adam optimizer algorithm\n        :param alpha: learning rate\n        :param beta1: weight for first moment\n        :param beta2: weight for second moment\n        :param epsilon: small number to avoid division by zero\n        :param var: ndarray, variable to be updated\n        :param grad: ndarray, gradient of var",
        "detail": "supervised_learning.optimization.9-Adam",
        "documentation": {}
    },
    {
        "label": "l2_reg_cost",
        "kind": 2,
        "importPath": "supervised_learning.regularization.0-l2_reg_cost",
        "description": "supervised_learning.regularization.0-l2_reg_cost",
        "peekOfCode": "def l2_reg_cost(cost, lambtha, weights, L, m):\n    \"\"\"\n        A function that calculates the cost of a network with L2 Regularization\n        formula = loss + lamda/2m * sum||w||**2\n    \"\"\"\n    reg_term = 0\n    for i in range(1, L + 1):\n        # construct key\n        weights_key = 'W' + str(i)\n        # extract weight matrix",
        "detail": "supervised_learning.regularization.0-l2_reg_cost",
        "documentation": {}
    },
    {
        "label": "l2_reg_cost",
        "kind": 5,
        "importPath": "supervised_learning.regularization.0-main",
        "description": "supervised_learning.regularization.0-main",
        "peekOfCode": "l2_reg_cost = __import__('0-l2_reg_cost').l2_reg_cost\nif __name__ == '__main__':\n    np.random.seed(0)\n    weights = {}\n    weights['W1'] = np.random.randn(256, 784)\n    weights['W2'] = np.random.randn(128, 256)\n    weights['W3'] = np.random.randn(10, 128)\n    cost = np.abs(np.random.randn(1))\n    print(cost)\n    cost = l2_reg_cost(cost, 0.1, weights, 3, 1000)",
        "detail": "supervised_learning.regularization.0-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_gradient_descent",
        "kind": 2,
        "importPath": "supervised_learning.regularization.1-l2_reg_gradient_descent",
        "description": "supervised_learning.regularization.1-l2_reg_gradient_descent",
        "peekOfCode": "def l2_reg_gradient_descent(Y, weights, cache, alpha, lambtha, L):\n    \"\"\"\n        A function that updates the weights and biases of NN\n        using gradient descent with L2 regularization\n        Formula:\n        W = W - alpha * (dW + (lambtha/m) * W)\n    \"\"\"\n    # store m number training examples\n    m = Y.shape[1]\n    # derivative of final layer",
        "detail": "supervised_learning.regularization.1-l2_reg_gradient_descent",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.regularization.1-main",
        "description": "supervised_learning.regularization.1-main",
        "peekOfCode": "def one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']\n    Y_train = lib['Y_train']",
        "detail": "supervised_learning.regularization.1-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_gradient_descent",
        "kind": 5,
        "importPath": "supervised_learning.regularization.1-main",
        "description": "supervised_learning.regularization.1-main",
        "peekOfCode": "l2_reg_gradient_descent = __import__('1-l2_reg_gradient_descent').l2_reg_gradient_descent\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']",
        "detail": "supervised_learning.regularization.1-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_cost",
        "kind": 2,
        "importPath": "supervised_learning.regularization.2-l2_reg_cost",
        "description": "supervised_learning.regularization.2-l2_reg_cost",
        "peekOfCode": "def l2_reg_cost(cost, model):\n    \"\"\"\n    A function that calculates the cost of a neural\n    \"\"\"\n    regularization_loss = model.losses\n    return cost + regularization_loss",
        "detail": "supervised_learning.regularization.2-l2_reg_cost",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "def one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    oh = np.zeros((classes, m))\n    oh[Y, np.arange(m)] = 1\n    return oh\nnp.random.seed(4)\nm = np.random.randint(1000, 2000)\nc = 10\nlib= np.load('../data/MNIST.npz')",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_cost",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "l2_reg_cost = __import__('2-l2_reg_cost').l2_reg_cost\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    oh = np.zeros((classes, m))\n    oh[Y, np.arange(m)] = 1\n    return oh\nnp.random.seed(4)\nm = np.random.randint(1000, 2000)\nc = 10",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "m = np.random.randint(1000, 2000)\nc = 10\nlib= np.load('../data/MNIST.npz')\nX = lib['X_train'][:m].reshape((m, -1))\nY = one_hot(lib['Y_train'][:m], c).T\nn0 = X.shape[1]\nn1, n2 = np.random.randint(10, 1000, 2)\nlam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "c = 10\nlib= np.load('../data/MNIST.npz')\nX = lib['X_train'][:m].reshape((m, -1))\nY = one_hot(lib['Y_train'][:m], c).T\nn0 = X.shape[1]\nn1, n2 = np.random.randint(10, 1000, 2)\nlam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "X = lib['X_train'][:m].reshape((m, -1))\nY = one_hot(lib['Y_train'][:m], c).T\nn0 = X.shape[1]\nn1, n2 = np.random.randint(10, 1000, 2)\nlam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "Y",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "Y = one_hot(lib['Y_train'][:m], c).T\nn0 = X.shape[1]\nn1, n2 = np.random.randint(10, 1000, 2)\nlam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "n0",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "n0 = X.shape[1]\nn1, n2 = np.random.randint(10, 1000, 2)\nlam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "lam",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "lam = 0.09\ntf.set_random_seed(0)\nx = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "x = tf.placeholder(tf.float32, (None, n0))\ny = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "y = tf.placeholder(tf.float32, (None, c))\na1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "a1",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "a1 = tf.layers.Dense(n1, activation=tf.nn.tanh, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(x)\na2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "a2 = tf.layers.Dense(n2, activation=tf.nn.sigmoid, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a1)\ny_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "y_pred = tf.layers.Dense(c, activation=None, kernel_initializer=tf.keras.initializers.VarianceScaling(scale=2.0, mode=(\"fan_avg\")), kernel_regularizer=tf.keras.regularizers.L2(lam))(a2)\ncost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "cost",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "cost = tf.losses.softmax_cross_entropy(y, y_pred)\nl2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "l2_cost",
        "kind": 5,
        "importPath": "supervised_learning.regularization.2-main",
        "description": "supervised_learning.regularization.2-main",
        "peekOfCode": "l2_cost = l2_reg_cost(cost)\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run(l2_cost, feed_dict={x: X, y: Y}))",
        "detail": "supervised_learning.regularization.2-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_create_layer",
        "kind": 2,
        "importPath": "supervised_learning.regularization.3-l2_reg_create_layer",
        "description": "supervised_learning.regularization.3-l2_reg_create_layer",
        "peekOfCode": "def l2_reg_create_layer(prev, n, activation, lambtha):\n    \"\"\"\n    A function that creates a neural network layer with L2 regularization.\n    \"\"\"\n    initializer = tf.keras.initializers.VarianceScaling(\n        scale=2.0,\n        mode=('fan_avg')\n    )\n    regularizer = tf.keras.regularizers.L2(lambtha)\n    layer = tf.keras.layers.Dense(",
        "detail": "supervised_learning.regularization.3-l2_reg_create_layer",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.regularization.3-main",
        "description": "supervised_learning.regularization.3-main",
        "peekOfCode": "def one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((m, classes))\n    one_hot[np.arange(m), Y] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']\n    Y_train = lib['Y_train']",
        "detail": "supervised_learning.regularization.3-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_cost",
        "kind": 5,
        "importPath": "supervised_learning.regularization.3-main",
        "description": "supervised_learning.regularization.3-main",
        "peekOfCode": "l2_reg_cost = __import__('2-l2_reg_cost').l2_reg_cost\nl2_reg_create_layer = __import__('3-l2_reg_create_layer').l2_reg_create_layer\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((m, classes))\n    one_hot[np.arange(m), Y] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')",
        "detail": "supervised_learning.regularization.3-main",
        "documentation": {}
    },
    {
        "label": "l2_reg_create_layer",
        "kind": 5,
        "importPath": "supervised_learning.regularization.3-main",
        "description": "supervised_learning.regularization.3-main",
        "peekOfCode": "l2_reg_create_layer = __import__('3-l2_reg_create_layer').l2_reg_create_layer\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((m, classes))\n    one_hot[np.arange(m), Y] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']",
        "detail": "supervised_learning.regularization.3-main",
        "documentation": {}
    },
    {
        "label": "dropout_forward_prop",
        "kind": 2,
        "importPath": "supervised_learning.regularization.4-dropout_forward_prop",
        "description": "supervised_learning.regularization.4-dropout_forward_prop",
        "peekOfCode": "def dropout_forward_prop(X, weights, L, keep_prob):\n    \"\"\"\n        A function that conduct forward prop using dropout\n    \"\"\"\n    cache = {'A0': X}\n    for layer in range(1, L):\n        Z = (np.matmul(weights[\"W\" + str(layer)],\n                       cache['A' + str(layer - 1)]) +\n             weights['b' + str(layer)])\n        A = np.tanh(Z)",
        "detail": "supervised_learning.regularization.4-dropout_forward_prop",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.regularization.4-main",
        "description": "supervised_learning.regularization.4-main",
        "peekOfCode": "def one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']\n    Y_train = lib['Y_train']",
        "detail": "supervised_learning.regularization.4-main",
        "documentation": {}
    },
    {
        "label": "dropout_forward_prop",
        "kind": 5,
        "importPath": "supervised_learning.regularization.4-main",
        "description": "supervised_learning.regularization.4-main",
        "peekOfCode": "dropout_forward_prop = __import__('4-dropout_forward_prop').dropout_forward_prop\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']",
        "detail": "supervised_learning.regularization.4-main",
        "documentation": {}
    },
    {
        "label": "dropout_gradient_descent",
        "kind": 2,
        "importPath": "supervised_learning.regularization.5-dropout_gradient_descent",
        "description": "supervised_learning.regularization.5-dropout_gradient_descent",
        "peekOfCode": "def dropout_gradient_descent(Y, weights, cache, alpha, keep_prob, L):\n    \"\"\"\n        A function that updates weights of NN with Dropout reg\n        using gradient descent\n        :param Y: ndarray, shape(classes,m) correct labels\n        :param weights: dict, weights and biases of NN\n        :param cache: dict, output and dropout mask of each layer\n        :param alpha: learning rate\n        :param keep_prob: proba a node will be kept\n        :param L: number of layer of network",
        "detail": "supervised_learning.regularization.5-dropout_gradient_descent",
        "documentation": {}
    },
    {
        "label": "one_hot",
        "kind": 2,
        "importPath": "supervised_learning.regularization.5-main",
        "description": "supervised_learning.regularization.5-main",
        "peekOfCode": "def one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']\n    Y_train = lib['Y_train']",
        "detail": "supervised_learning.regularization.5-main",
        "documentation": {}
    },
    {
        "label": "dropout_forward_prop",
        "kind": 5,
        "importPath": "supervised_learning.regularization.5-main",
        "description": "supervised_learning.regularization.5-main",
        "peekOfCode": "dropout_forward_prop = __import__('4-dropout_forward_prop').dropout_forward_prop\ndropout_gradient_descent = __import__('5-dropout_gradient_descent').dropout_gradient_descent\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')",
        "detail": "supervised_learning.regularization.5-main",
        "documentation": {}
    },
    {
        "label": "dropout_gradient_descent",
        "kind": 5,
        "importPath": "supervised_learning.regularization.5-main",
        "description": "supervised_learning.regularization.5-main",
        "peekOfCode": "dropout_gradient_descent = __import__('5-dropout_gradient_descent').dropout_gradient_descent\ndef one_hot(Y, classes):\n    \"\"\"convert an array to a one-hot matrix\"\"\"\n    m = Y.shape[0]\n    one_hot = np.zeros((classes, m))\n    one_hot[Y, np.arange(m)] = 1\n    return one_hot\nif __name__ == '__main__':\n    lib= np.load('../data/MNIST.npz')\n    X_train_3D = lib['X_train']",
        "detail": "supervised_learning.regularization.5-main",
        "documentation": {}
    },
    {
        "label": "dropout_create_layer",
        "kind": 2,
        "importPath": "supervised_learning.regularization.6-dropout_create_layer",
        "description": "supervised_learning.regularization.6-dropout_create_layer",
        "peekOfCode": "def dropout_create_layer(prev, n, activation, keep_prob, training=True):\n    \"\"\"\n    A function that creates a layer of a neural network using dropout\n    regularization.\n    \"\"\"\n    # Initialize layer weights using He initialization\n    init = tf.keras.initializers.VarianceScaling(scale=2.0, mode='fan_avg')\n    # Create dense layer\n    dense_layer = tf.keras.layers.Dense(units=n, activation=activation,\n                                        kernel_initializer=init)",
        "detail": "supervised_learning.regularization.6-dropout_create_layer",
        "documentation": {}
    },
    {
        "label": "dropout_create_layer",
        "kind": 5,
        "importPath": "supervised_learning.regularization.6-main",
        "description": "supervised_learning.regularization.6-main",
        "peekOfCode": "dropout_create_layer = __import__('6-dropout_create_layer').dropout_create_layer\nif __name__ == '__main__':\n    tf.set_random_seed(0)\n    np.random.seed(0)\n    x = tf.placeholder(tf.float32, shape=[None, 784])\n    X = np.random.randint(0, 256, size=(10, 784))\n    a = dropout_create_layer(x, 256, tf.nn.tanh, 0.8)\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n        print(sess.run(a, feed_dict={x: X}))",
        "detail": "supervised_learning.regularization.6-main",
        "documentation": {}
    },
    {
        "label": "early_stopping",
        "kind": 2,
        "importPath": "supervised_learning.regularization.7-early_stopping",
        "description": "supervised_learning.regularization.7-early_stopping",
        "peekOfCode": "def early_stopping(cost, opt_cost, threshold, patience, count):\n    \"\"\"\n        A function that determines if should stop gradient descent early\n    \"\"\"\n    if opt_cost - cost > threshold:\n        count = 0\n    else:\n        count += 1\n    return count == patience, count",
        "detail": "supervised_learning.regularization.7-early_stopping",
        "documentation": {}
    },
    {
        "label": "early_stopping",
        "kind": 5,
        "importPath": "supervised_learning.regularization.7-main",
        "description": "supervised_learning.regularization.7-main",
        "peekOfCode": "early_stopping = __import__('7-early_stopping').early_stopping\nif __name__ == '__main__':\n    print(early_stopping(1.0, 1.9, 0.5, 15, 5))\n    print(early_stopping(1.1, 1.5, 0.5, 15, 2))\n    print(early_stopping(1.0, 1.5, 0.5, 15, 8))",
        "detail": "supervised_learning.regularization.7-main",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.0-initialize",
        "description": "unsupervised_learning.clustering.0-initialize",
        "peekOfCode": "def initialize(X, k):\n    \"\"\"\n    A function that initializes cluster centroids for K-means.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        return None\n    _, d = X.shape\n    if not isinstance(k, int) or k <= 0:\n        return None\n    centroids = np.random.uniform(low=np.min(",
        "detail": "unsupervised_learning.clustering.0-initialize",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.0-main",
        "description": "unsupervised_learning.clustering.0-main",
        "peekOfCode": "initialize = __import__('0-initialize').initialize\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.0-main",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.1-kmeans",
        "description": "unsupervised_learning.clustering.1-kmeans",
        "peekOfCode": "def initialize(X, k):\n    \"\"\"\n    A function that initializes cluster centroids for K-means.\n    \"\"\"\n    _, d = X.shape\n    centroids = np.random.uniform(low=np.min(\n        X, axis=0), high=np.max(X, axis=0), size=(k, d))\n    return centroids\ndef kmeans(X, k, iterations=1000):\n    \"\"\"",
        "detail": "unsupervised_learning.clustering.1-kmeans",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.1-kmeans",
        "description": "unsupervised_learning.clustering.1-kmeans",
        "peekOfCode": "def kmeans(X, k, iterations=1000):\n    \"\"\"\n    A function that performs K-means on a dataset.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        return None, None\n    if not isinstance(k, int) or k <= 0:\n        return None, None\n    if not isinstance(iterations, int) or iterations <= 0:\n        return None, None",
        "detail": "unsupervised_learning.clustering.1-kmeans",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.1-main",
        "description": "unsupervised_learning.clustering.1-main",
        "peekOfCode": "kmeans = __import__('1-kmeans').kmeans\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.1-main",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.10-kmeans",
        "description": "unsupervised_learning.clustering.10-kmeans",
        "peekOfCode": "def kmeans(X, k):\n    \"\"\"A function that performs K-means on a dataset:\n    X is a numpy.ndarray of shape (n, d) containing the dataset\n    k is the number of clusters\n    Returns: C, clss\n    C is a numpy.ndarray of shape (k, d) containing the centroid means for\n    each cluster\n    clss is a numpy.ndarray of shape (n,) containing the index of the cluster\n    in C that each data point belongs to\n    \"\"\"",
        "detail": "unsupervised_learning.clustering.10-kmeans",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.10-main",
        "description": "unsupervised_learning.clustering.10-main",
        "peekOfCode": "kmeans = __import__('10-kmeans').kmeans\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.10-main",
        "documentation": {}
    },
    {
        "label": "gmm",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.11-gmm",
        "description": "unsupervised_learning.clustering.11-gmm",
        "peekOfCode": "def gmm(X, k):\n    \"\"\"A function that calculates a GMM from a dataset:\n    X is a numpy.ndarray of shape (n, d) containing the dataset\n    k is the number of clusters\n    Returns: pi, m, S, clss, bic\n    pi is a numpy.ndarray of shape (k,) containing the cluster priors\n    m is a numpy.ndarray of shape (k, d) containing the centroid means\n    S is a numpy.ndarray of shape (k, d, d) containing the covariance matrices\n    clss is a numpy.ndarray of shape (n,) containing the cluster indices for\n    each data point",
        "detail": "unsupervised_learning.clustering.11-gmm",
        "documentation": {}
    },
    {
        "label": "gmm",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.11-main",
        "description": "unsupervised_learning.clustering.11-main",
        "peekOfCode": "gmm = __import__('11-gmm').gmm\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    pi, m, S, clss, bic = gmm(X, 4)",
        "detail": "unsupervised_learning.clustering.11-main",
        "documentation": {}
    },
    {
        "label": "agglomerative",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.12-agglomerative",
        "description": "unsupervised_learning.clustering.12-agglomerative",
        "peekOfCode": "def agglomerative(X, dist):\n    \"\"\"A function that performs agglomerative clustering on a dataset:\n    X is a numpy.ndarray of shape (n, d) containing the dataset\n    dist is the maximum cophenetic distance for all clusters\n    Performs agglomerative clustering with Ward linkage\n    Displays the dendrogram with each cluster displayed in a different color\n    Returns: clss, a numpy.ndarray of shape (n,) containing the cluster indices\n    for each data point\n    \"\"\"\n    dendrogram = scipy.cluster.hierarchy.linkage(X, method='ward')",
        "detail": "unsupervised_learning.clustering.12-agglomerative",
        "documentation": {}
    },
    {
        "label": "agglomerative",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.12-main",
        "description": "unsupervised_learning.clustering.12-main",
        "peekOfCode": "agglomerative = __import__('12-agglomerative').agglomerative\nif __name__ == '__main__':\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=100)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=100)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.12-main",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.2-main",
        "description": "unsupervised_learning.clustering.2-main",
        "peekOfCode": "kmeans = __import__('1-kmeans').kmeans\nvariance = __import__('2-variance').variance\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)",
        "detail": "unsupervised_learning.clustering.2-main",
        "documentation": {}
    },
    {
        "label": "variance",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.2-main",
        "description": "unsupervised_learning.clustering.2-main",
        "peekOfCode": "variance = __import__('2-variance').variance\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.2-main",
        "documentation": {}
    },
    {
        "label": "variance",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.2-variance",
        "description": "unsupervised_learning.clustering.2-variance",
        "peekOfCode": "def variance(X, C):\n    \"\"\"\n    A function that calculates the total variance for a dataset.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        return None\n    if not isinstance(C, np.ndarray) or len(C.shape) != 2:\n        return None\n    if C.shape[1] != X.shape[1]:\n        return None",
        "detail": "unsupervised_learning.clustering.2-variance",
        "documentation": {}
    },
    {
        "label": "optimum_k",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.3-main",
        "description": "unsupervised_learning.clustering.3-main",
        "peekOfCode": "optimum_k = __import__('3-optimum').optimum_k\nif __name__ == \"__main__\":\n    np.random.seed(0)\n    a = np.random.multivariate_normal([30, 40], [[16, 0], [0, 16]], size=50)\n    b = np.random.multivariate_normal([10, 25], [[16, 0], [0, 16]], size=50)\n    c = np.random.multivariate_normal([40, 20], [[16, 0], [0, 16]], size=50)\n    d = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=50)\n    e = np.random.multivariate_normal([20, 70], [[16, 0], [0, 16]], size=50)\n    X = np.concatenate((a, b, c, d, e), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.3-main",
        "documentation": {}
    },
    {
        "label": "optimum_k",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.3-optimum",
        "description": "unsupervised_learning.clustering.3-optimum",
        "peekOfCode": "def optimum_k(X, kmin=1, kmax=None, iterations=1000):\n    \"\"\"A function that determines the optimum number of clusters\"\"\"\n    try:\n        if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n            return None, None\n        if not isinstance(iterations, int) or iterations < 1:\n            return None, None\n        if kmax is not None:\n            if type(kmax) is not int or kmax < 1:\n                return None, None",
        "detail": "unsupervised_learning.clustering.3-optimum",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.3-optimum",
        "description": "unsupervised_learning.clustering.3-optimum",
        "peekOfCode": "kmeans = __import__('1-kmeans').kmeans\nvariance = __import__('2-variance').variance\ndef optimum_k(X, kmin=1, kmax=None, iterations=1000):\n    \"\"\"A function that determines the optimum number of clusters\"\"\"\n    try:\n        if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n            return None, None\n        if not isinstance(iterations, int) or iterations < 1:\n            return None, None\n        if kmax is not None:",
        "detail": "unsupervised_learning.clustering.3-optimum",
        "documentation": {}
    },
    {
        "label": "variance",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.3-optimum",
        "description": "unsupervised_learning.clustering.3-optimum",
        "peekOfCode": "variance = __import__('2-variance').variance\ndef optimum_k(X, kmin=1, kmax=None, iterations=1000):\n    \"\"\"A function that determines the optimum number of clusters\"\"\"\n    try:\n        if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n            return None, None\n        if not isinstance(iterations, int) or iterations < 1:\n            return None, None\n        if kmax is not None:\n            if type(kmax) is not int or kmax < 1:",
        "detail": "unsupervised_learning.clustering.3-optimum",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.4-initialize",
        "description": "unsupervised_learning.clustering.4-initialize",
        "peekOfCode": "def initialize(X, k):\n    \"\"\"\n    A function that initializes the priors, means, and covariances for a GMM.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        return None, None, None\n    if not isinstance(k, int) or k <= 0:\n        return None, None, None\n    priors = np.repeat(1.0 / k, k)\n    cluster_means, _ = kmeans(X, k)",
        "detail": "unsupervised_learning.clustering.4-initialize",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.4-initialize",
        "description": "unsupervised_learning.clustering.4-initialize",
        "peekOfCode": "kmeans = __import__('1-kmeans').kmeans\ndef initialize(X, k):\n    \"\"\"\n    A function that initializes the priors, means, and covariances for a GMM.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        return None, None, None\n    if not isinstance(k, int) or k <= 0:\n        return None, None, None\n    priors = np.repeat(1.0 / k, k)",
        "detail": "unsupervised_learning.clustering.4-initialize",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.4-main",
        "description": "unsupervised_learning.clustering.4-main",
        "peekOfCode": "initialize = __import__('4-initialize').initialize\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    pi, m, S = initialize(X, 4)",
        "detail": "unsupervised_learning.clustering.4-main",
        "documentation": {}
    },
    {
        "label": "pdf",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.5-main",
        "description": "unsupervised_learning.clustering.5-main",
        "peekOfCode": "pdf = __import__('5-pdf').pdf\nif __name__ == '__main__':\n    np.random.seed(0)\n    m = np.array([12, 30, 10])\n    S = np.array([[36, -30, 15], [-30, 100, -20], [15, -20, 25]])\n    X = np.random.multivariate_normal(m, S, 10000)\n    P = pdf(X, m, S)\n    print(P)",
        "detail": "unsupervised_learning.clustering.5-main",
        "documentation": {}
    },
    {
        "label": "pdf",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.5-pdf",
        "description": "unsupervised_learning.clustering.5-pdf",
        "peekOfCode": "def pdf(data_points, mean, covariance):\n    \"\"\"\n    A function that calculates the probability density\n    function of a multivariate Gaussian distribution.\n    \"\"\"\n    if not isinstance(data_points, np.ndarray) or len(data_points.shape) != 2:\n        return None\n    num_features = data_points.shape[1]\n    if not isinstance(mean, np.ndarray) or len(mean.shape) != 1:\n        return None",
        "detail": "unsupervised_learning.clustering.5-pdf",
        "documentation": {}
    },
    {
        "label": "expectation",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.6-expectation",
        "description": "unsupervised_learning.clustering.6-expectation",
        "peekOfCode": "def expectation(X, pi, m, S):\n    \"\"\"\n    A function that calculates the expectation step\n    in the EM algorithm for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    pi is a numpy.ndarray of shape (k,) containing the priors for each cluster\n    m is a numpy.ndarray of shape (k, d) containing the centroid means for\n    each cluster\n    S is a numpy.ndarray of shape (k, d, d) containing the covariance matrices\n    for each cluster",
        "detail": "unsupervised_learning.clustering.6-expectation",
        "documentation": {}
    },
    {
        "label": "pdf",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.6-expectation",
        "description": "unsupervised_learning.clustering.6-expectation",
        "peekOfCode": "pdf = __import__('5-pdf').pdf\ndef expectation(X, pi, m, S):\n    \"\"\"\n    A function that calculates the expectation step\n    in the EM algorithm for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    pi is a numpy.ndarray of shape (k,) containing the priors for each cluster\n    m is a numpy.ndarray of shape (k, d) containing the centroid means for\n    each cluster\n    S is a numpy.ndarray of shape (k, d, d) containing the covariance matrices",
        "detail": "unsupervised_learning.clustering.6-expectation",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.6-main",
        "description": "unsupervised_learning.clustering.6-main",
        "peekOfCode": "initialize = __import__('4-initialize').initialize\nexpectation = __import__('6-expectation').expectation\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.6-main",
        "documentation": {}
    },
    {
        "label": "expectation",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.6-main",
        "description": "unsupervised_learning.clustering.6-main",
        "peekOfCode": "expectation = __import__('6-expectation').expectation\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    pi, m, S = initialize(X, 4)",
        "detail": "unsupervised_learning.clustering.6-main",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.7-main",
        "description": "unsupervised_learning.clustering.7-main",
        "peekOfCode": "initialize = __import__('4-initialize').initialize\nexpectation = __import__('6-expectation').expectation\nmaximization = __import__('7-maximization').maximization\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)",
        "detail": "unsupervised_learning.clustering.7-main",
        "documentation": {}
    },
    {
        "label": "expectation",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.7-main",
        "description": "unsupervised_learning.clustering.7-main",
        "peekOfCode": "expectation = __import__('6-expectation').expectation\nmaximization = __import__('7-maximization').maximization\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)",
        "detail": "unsupervised_learning.clustering.7-main",
        "documentation": {}
    },
    {
        "label": "maximization",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.7-main",
        "description": "unsupervised_learning.clustering.7-main",
        "peekOfCode": "maximization = __import__('7-maximization').maximization\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    pi, m, S = initialize(X, 4)",
        "detail": "unsupervised_learning.clustering.7-main",
        "documentation": {}
    },
    {
        "label": "maximization",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.7-maximization",
        "description": "unsupervised_learning.clustering.7-maximization",
        "peekOfCode": "def maximization(X, g):\n    \"\"\"A function that calculates the maximization step in the EM algorithm\"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2\\\n            or not isinstance(g, np.ndarray) or len(g.shape) != 2\\\n            or X.shape[0] != g.shape[1]:\n        return None, None, None\n    n, d = X.shape\n    k = g.shape[0]\n    probs = np.sum(g, axis=0)\n    validation = np.ones((n,))",
        "detail": "unsupervised_learning.clustering.7-maximization",
        "documentation": {}
    },
    {
        "label": "expectation_maximization",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.8-EM",
        "description": "unsupervised_learning.clustering.8-EM",
        "peekOfCode": "def expectation_maximization(X, k, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"\n    A function that performs the expectation maximization for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    k is a positive integer containing the number of clusters\n    iterations is a positive integer containing the maximum number of\n    iterations for the algorithm\n    tol is a non-negative float containing tolerance of the log likelihood,\n    used to determine early stopping i.e. if the difference is less than or\n    equal to tol you should stop the algorithm",
        "detail": "unsupervised_learning.clustering.8-EM",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.8-EM",
        "description": "unsupervised_learning.clustering.8-EM",
        "peekOfCode": "initialize = __import__('4-initialize').initialize\nexpectation = __import__('6-expectation').expectation\nmaximization = __import__('7-maximization').maximization\ndef expectation_maximization(X, k, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"\n    A function that performs the expectation maximization for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    k is a positive integer containing the number of clusters\n    iterations is a positive integer containing the maximum number of\n    iterations for the algorithm",
        "detail": "unsupervised_learning.clustering.8-EM",
        "documentation": {}
    },
    {
        "label": "expectation",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.8-EM",
        "description": "unsupervised_learning.clustering.8-EM",
        "peekOfCode": "expectation = __import__('6-expectation').expectation\nmaximization = __import__('7-maximization').maximization\ndef expectation_maximization(X, k, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"\n    A function that performs the expectation maximization for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    k is a positive integer containing the number of clusters\n    iterations is a positive integer containing the maximum number of\n    iterations for the algorithm\n    tol is a non-negative float containing tolerance of the log likelihood,",
        "detail": "unsupervised_learning.clustering.8-EM",
        "documentation": {}
    },
    {
        "label": "maximization",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.8-EM",
        "description": "unsupervised_learning.clustering.8-EM",
        "peekOfCode": "maximization = __import__('7-maximization').maximization\ndef expectation_maximization(X, k, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"\n    A function that performs the expectation maximization for a GMM:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    k is a positive integer containing the number of clusters\n    iterations is a positive integer containing the maximum number of\n    iterations for the algorithm\n    tol is a non-negative float containing tolerance of the log likelihood,\n    used to determine early stopping i.e. if the difference is less than or",
        "detail": "unsupervised_learning.clustering.8-EM",
        "documentation": {}
    },
    {
        "label": "expectation_maximization",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.8-main",
        "description": "unsupervised_learning.clustering.8-main",
        "peekOfCode": "expectation_maximization = __import__('8-EM').expectation_maximization\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    k = 4",
        "detail": "unsupervised_learning.clustering.8-main",
        "documentation": {}
    },
    {
        "label": "BIC",
        "kind": 2,
        "importPath": "unsupervised_learning.clustering.9-BIC",
        "description": "unsupervised_learning.clustering.9-BIC",
        "peekOfCode": "def BIC(X, kmin=1, kmax=None, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"A function that finds the best number of clusters for\n    a GMM using the Bayesian Information Criterion:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    kmin is a positive integer containing the minimum number of clusters to\n    check for (inclusive)\n    kmax is a positive integer containing the maximum number of clusters to\n    check for (inclusive)\n    If kmax is None, kmax should be set to the maximum number of clusters\n    possible",
        "detail": "unsupervised_learning.clustering.9-BIC",
        "documentation": {}
    },
    {
        "label": "expectation_maximization",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.9-BIC",
        "description": "unsupervised_learning.clustering.9-BIC",
        "peekOfCode": "expectation_maximization = __import__('8-EM').expectation_maximization\ndef BIC(X, kmin=1, kmax=None, iterations=1000, tol=1e-5, verbose=False):\n    \"\"\"A function that finds the best number of clusters for\n    a GMM using the Bayesian Information Criterion:\n    X is a numpy.ndarray of shape (n, d) containing the data set\n    kmin is a positive integer containing the minimum number of clusters to\n    check for (inclusive)\n    kmax is a positive integer containing the maximum number of clusters to\n    check for (inclusive)\n    If kmax is None, kmax should be set to the maximum number of clusters",
        "detail": "unsupervised_learning.clustering.9-BIC",
        "documentation": {}
    },
    {
        "label": "BIC",
        "kind": 5,
        "importPath": "unsupervised_learning.clustering.9-main",
        "description": "unsupervised_learning.clustering.9-main",
        "peekOfCode": "BIC = __import__('9-BIC').BIC\nif __name__ == '__main__':\n    np.random.seed(11)\n    a = np.random.multivariate_normal([30, 40], [[75, 5], [5, 75]], size=10000)\n    b = np.random.multivariate_normal([5, 25], [[16, 10], [10, 16]], size=750)\n    c = np.random.multivariate_normal([60, 30], [[16, 0], [0, 16]], size=750)\n    d = np.random.multivariate_normal([20, 70], [[35, 10], [10, 35]], size=1000)\n    X = np.concatenate((a, b, c, d), axis=0)\n    np.random.shuffle(X)\n    best_k, best_result, l, b = BIC(X, kmin=1, kmax=10)",
        "detail": "unsupervised_learning.clustering.9-main",
        "documentation": {}
    },
    {
        "label": "pca",
        "kind": 2,
        "importPath": "unsupervised_learning.dimensionality_reduction.0-pca",
        "description": "unsupervised_learning.dimensionality_reduction.0-pca",
        "peekOfCode": "def pca(X, var=0.95):\n    \"\"\"\n    A function that performs principal components\n    analysis (PCA) on a dataset\n    \"\"\"\n    u, s, v = np.linalg.svd(X)\n    ratios = list(x / np.sum(s) for x in s)\n    variance = np.cumsum(ratios)\n    nd = np.argwhere(variance >= var)[0, 0]\n    W = v.T[:, :(nd + 1)]",
        "detail": "unsupervised_learning.dimensionality_reduction.0-pca",
        "documentation": {}
    },
    {
        "label": "pca",
        "kind": 2,
        "importPath": "unsupervised_learning.dimensionality_reduction.1-pca",
        "description": "unsupervised_learning.dimensionality_reduction.1-pca",
        "peekOfCode": "def pca(X, ndim):\n    \"\"\"\n    A function that performs principal components analysis\n    (PCA) on a dataset\n    \"\"\"\n    mean = np.mean(X, axis=0, keepdims=True)\n    A = X - mean\n    u, s, v = np.linalg.svd(A)\n    W = v.T[:, :ndim]\n    T = np.matmul(A, W)",
        "detail": "unsupervised_learning.dimensionality_reduction.1-pca",
        "documentation": {}
    }
]